using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using DungeonExplorer;
using System.Runtime.Runtime.Serialization.Formatters.Binary;

namespace DungeonExplorer
{
    // Interface (ICollectible) for items

    public interface ICollectible
    {
      void Use();
    } 

   // Interface (IDamageable) for accepting damage

   public interface IDamageable
    {
     void TakeDamage(int damage)

    } 

   public class abstract Creature : IDamageable
   {
     // Main common properties
     public string name {get;protected set;} // (E) Any part of the code could read the name , but only this class and its subclasses could assign them.
     protected int health; // (E) (Protected) => visible to the Creature class and its subclasses , but hidden from any irrelevant classes (Ensuring Encapsulation).
     public int Health => health; //  (Read-only property)
     public bool ALive => health > 0; //  (Read-only property) , returns true (if health is more than zero).

     // Constructor (Protected) => Can not be initialized , but subclasses could call it via base(...)
     protected Creature (string name, int health) 
     {
       // Error handling for name entry
       Debug.Assert(!string.IsNullOrWhiteSpace(name), "Creature name can not be left empty of null! "); // Ensures "name" is never empty or null.
       Debug.Assert(health > 0 , "Health needs to be positive! "); // Ensures health is always positive.
       Name = name;
       this.health = health; // *initializes the internal "health" field to the passed-in value
     }

     public virtual void Damage (int value) // Virtual => allows subclasses to override this method if they need special "damage" logic.
     {
      Debug.Assert(value >= 0 , "Damage value needs to be positive! "); // Ensure damage value is always positive.
      health = Math.Max(0, health - value); // Ensures that no negative points are used.
     }

     // Dynamic polymorphism for different attack behaviours for different monsters
     public abstract void Attack (Player player); // Every concrete subclass MUST implement.
    }

   // Player class 
   public class Player : Creature
   {
      public Inventory Inventory {get; } = new Inventory(); // (E*) Read only property (Inventory) + internal initialiser creates a new Inventory when a new player is constructed.
      public int totalScore {get; private set; } // (E*) Holds player's total points , only methods inside the "Player" class can change it.
      public int Level {get; private set; } // (E*) tracks progression level of player + External alterantion (outside the player class) is NOT possible.

      // Static polymorphism (Overloaded constructers)
      public Player() :this ("player" , 100 ,1 ) {} // Paramater-less contsructor , ensuring the default assignment of the three- argument constructor 
      // Constructor (in addtion to the assignment of the base properties).
      public Player (string name, int health, int level): base (name, health)
      {
        Debug.Assert( level > 0 , "Level value must be 1 or more! "); // Error handling (Ensures level value is never neagtive.)
        Level = level;
      }

      // GainScore method ("void" to allow it to be overriden if needed)

      public void GainScore (int result)
      {
        Debug.Assert( result >= 0 , "Resulted points can not be neagtive! "); // Ensures that the total score is never a negative value.

        Score += result;
        if (Score >= Level *100) // A mechanism used to ensure enough result pints are declared in oreder to move to the next level (current level * 100).
        {
          Level++;
          Console.WriteLine($"Next level : {Level} is approached !");

        }
      }

      // Attack method (overriden from the base class and replaces the abstract method declaration in the base clase "Creature").
      public overrirde void Attack (Player player)
      {

      }
      
    }

    public abstract class Monster : Creature
    {
      protected int power;
      protected static readonly Random rng = new Random ();
      
      // Constructer
      protected Monster (string name, int health, int power ) :base (name, health)
      {
        Debug.Assert( power > 0 , "Power value can not be negative !");
        this.power= power;


      }

      // Attack method from base class "creature"
      public override void Attack (Player player)
      {
        Debug.Assert(player !=null , "Player must not be empty or null !");
        // "Flee of monster" condition
        if (health < 0.2 *power) // Monster flees if health is below 20% of its power
        {
          Console.WriteLine($"Monster : "{Name}" flees! ");
        }

        else
        {
          Strike(player);
        }
      }

      public virtual void Strike (IDamageable target)
      {
        Debug.Assert(target != null , "Strike target can not be null or empty !");
        target.TakeDamage(power);
        Console.WriteLine ($"{Name} hits for {power} damage! "); //*



      }

      public int Power => power; //Constructor ???
    }

    public class Snake : Monster
    {
      public Snake (): base ("Snake" , 30 , 5) {} // Static polymorphism
      public overrirde void Strike (IDamageable target)
      {
        base.Strike(target); // Extra feature
      }
    }

    public class Bat : Monster
    {
      public Bat (): base ("Bat", 100 ,25 ) {} // Static polymorphism
      public override void Attack (IDamageable target)
      {
        base.Strike(target); // Extra feature
      }
      
    }

    public class Inventory
    {

      private readonly List<Item> items = new List<Item> (); // Dynamic array + supports LINQ + (E*) + "readonly" prevents field from being reassigned

      public void addItem (Item item)
      {

        Debug.Assert (item != null ," Null item CAN NOT be added to inventory! "); // Error handling
        items.Add(item); //stores item in the list
      }

      public bool removeItem (Item item) // bool is used as a data type as the function returns true if the item is successfully removed.
      {
        Debug.Assert(item != null ,"Null item CAN NOT be removed from inventory! "); // Error handling
        return items.removeItem(item); // removes item and returns (true / false).

      }

      // LINQ filter
      public IEnumerable<T> Filter <T>() where T : Item => items.ofType<T>(); // "Generic" + returns only items of the same type of T (T= Item).

      // To find the strongest weapon using LINQ
      public Weapon StongestWeapon()
      {
        var weapon = items.ofType<Weapon>() // 1) Filters weapon instances
                           .OrderByDescendingly(w => w.Damage) // 2) sorts by "Damage" in a descending order
                           .FirstOrDefault(); //Selects the first in the order to be the strongest. 

        Debug.Assert(weapon != null , "No weapons present in inventory! "); // Error handling
        return weapon;                   
      }

      public void NameSort() // Method to alphabetically sort the inventory
      {
        items.Sort((a,b) => string.Compare(a.Name , b.Name, StringComparison.Ordinal)); // Lambda Comparer orders items by their "Name", allowing the player to view the items in a logical order.

      }


    }

    //GameMap class

    public class GameMap
    {
      public List <Room> Rooms {get;} = new List <Room>();//(E*) + read-only + initialisation
      public Room Current {get; private set;}
      private static readonly Randon rng = new Random(); // Can only be changed in this class + can be read other classes

      public GameMap
      {
        // 7 rooms 
        for (int i =1 ; i<=7 ; i++)
        {
          Rooms.Add(new Room ($"Room {i}")); // Loops from rooms 1 to 7 

        }

        //connections
        for (int i = 0; i<6 ; i++) // iterates through the first six rooms and links them together usinf "right" and "left logic.
        {
          Rooms[i].Adjacent["Right"] =Rooms[i+1];// the current room's "Right"  is the next room
          Rooms[i].Adjacent["Left"] = Rooms [i]; // The next room's "Left" is the current room
        }

        Rooms[4].Trap = true; // challenge in room 4

        // Random population of monsters into the rooms
        foreach(var room in Rooms) //iteration over every room in the game
        {
          if ( rng.NextDouble() < 0.5) // 50%  (probability between empty and overcrowded rooms) // Check for monsters // Controls difficulty
          {
            room.Monsters.Add(
                 rng.Next(2) == 0; // returns either 0 or 1  
                 ? (Monster) new Bat()
                 : new Snake()
            );


          }

          if (rng.NextDouble() < 0.3) // Check for items (30% probability) (controls difficulty)
          {
            room.Items.Add(
                 rng.Next(2) == 0
                 ? (Item) new Weapon ("Sword",10);
                 : new Potion ("E", 20);
            );     
          }

        }

        // starting room setting , making sure that at least on room exists.
        Current = Rooms.FirstorDefault();
        Debug.Assert(Current != null ,"At least one room should be there in the map! "); // Error handling


      }

      public void Move (string command)
      {
        Debug.Assert(command != null, "Command CAN NOT be null or empty! "); // Error handling

        if (!Current.Adjacent.TryGetValue(command, out var next)) // Attempt to find an adjacent room in the chosen direction determined by the command.
        {
          throw new InvalidOperationException("This way is in valid! ");
        } 

        Current = next; // goes to the new room
        if (Current.Trap)
        {
          // Trap logic may be added here
          Console.WriteLine("A trap is found , (You lose 10 health points!)");
        }

      }
    }

    

    




}     




     