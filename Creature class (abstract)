using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using DungeonExplorer;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace DungeonExplorer
{


  public static class ProvideRandom
  {
    public static Random Instance {get; } = new Random(); // Initialization
  }
    // Interface (ICollectible) for items

    public interface ICollectible
    {
      string Name {get;}
      void Collect(Player player); //*
    } 

   // Interface (IDamageable) for accepting damage

   public interface IDamageable
    {
      int Health{get;}
      bool IsAlive {get;}
      void Damage(int damage);

    } 

   public class abstract Creature : IDamageable
   {
     // Main common properties
     public string Name {get;} // (E) Any part of the code could read the name , but only this class and its subclasses could assign them.
     protected int _health; // (E) (Protected) => visible to the Creature class and its subclasses , but hidden from any irrelevant classes (Ensuring Encapsulation).
     public int Health => _health; //  (Read-only property)
     public bool ALive => health > 0; //  (Read-only property) , returns true (if health is more than zero).

     // Constructor (Protected) => Can not be initialized , but subclasses could call it via base(...)
     protected Creature (string name, int health) 
     {
       // Error handling for name entry
       if(!string.IsNullOrWhiteSpace(name))// Ensures "name" is never empty or null.
       {
        throw new ArgumentException("Name is required:" , nameof (name));
       }
       if (startingHealth <= 0)  // Ensures health is always positive.
       {
        throw new ArgumentOutOfRangeException(nameof (startingHealth), "Health MUST be positive!");
       }
       Name = name;
       _health = startingHealth ; // *initializes the internal "health" field to the passed-in value
     }

     public virtual void Damage (int value) // Virtual => allows subclasses to override this method if they need special "damage" logic.
     {
      if(value < 0) // Ensure damage value is always positive.
      {
        throw new ArgumentOutOfRangeException(nameof (value), "Damge value MUST be positive!");
      }

      health = Math.Max(0, health - value); // Ensures that no negative points are used.
     }

     // Dynamic polymorphism for different attack behaviours for different monsters
     public abstract void Attack (IDamageable target); // Every concrete subclass MUST implement.
    }

   // Player class 
   public class Player : Creature
   {
      private readonly List<ICollectible> _inventory= new();

      public CollectionReadOnly<ICollectible> Inventory => _inventory.AsReadOnly();

      public int totalScore {get; private set; } // (E*) Holds player's total points , only methods inside the "Player" class can change it.

      public int Level {get; private set; } // (E*) tracks progression level of player + External alterantion (outside the player class) is NOT possible.

      // Static polymorphism (Overloaded constructers)
      public Player(string name = "Gamer" , int health = 100 , int initialLevel = 1) :base(name, health)
      {
        if (initialLevel < 1)
        {
          throw new ArgumentOutOfRangeException(nameof (initialLevel) , "Level MUST ")
        }

      }
       // Paramater-less contsructor , ensuring the default assignment of the three- argument constructor 
      // Constructor (in addtion to the assignment of the base properties).
      public Player (string name, int health, int level): base (name, health)
      {
        Debug.Assert( level > 0 , "Level value must be 1 or more! "); // Error handling (Ensures level value is never neagtive.)
        Level = level;
      }

      // GainScore method ("void" to allow it to be overriden if needed)

      public void GainScore (int result)
      {
        Debug.Assert( result >= 0 , "Resulted points can not be neagtive! "); // Ensures that the total score is never a negative value.

        Score += result;
        if (Score >= Level *100) // A mechanism used to ensure enough result pints are declared in oreder to move to the next level (current level * 100).
        {
          Level++;
          Console.WriteLine($"Next level : {Level} is approached !");

        }
      }

      // Attack method (overriden from the base class and replaces the abstract method declaration in the base clase "Creature").
      public overrirde void Attack (Player player)
      {

      }
      
    }

    public abstract class Monster : Creature
    {
      protected int power;
      protected static readonly Random rng = new Random ();
      
      // Constructer
      protected Monster (string name, int health, int power ) :base (name, health)
      {
        Debug.Assert( power > 0 , "Power value can not be negative !");
        this.power= power;


      }

      // Attack method from base class "creature"
      public override void Attack (Player player)
      {
        Debug.Assert(player !=null , "Player must not be empty or null !");
        // "Flee of monster" condition
        if (health < 0.2 *power) // Monster flees if health is below 20% of its power
        {
          Console.WriteLine($"Monster : "{Name}" flees! ");
        }

        else
        {
          Strike(player);
        }
      }

      public virtual void Strike (IDamageable target)
      {
        Debug.Assert(target != null , "Strike target can not be null or empty !");
        target.TakeDamage(power);
        Console.WriteLine ($"{Name} hits for {power} damage! "); //*



      }

      public int Power => power; //Constructor ???
    }

    public class Snake : Monster
    {
      public Snake (): base ("Snake" , 30 , 5) {} // Static polymorphism
      public overrirde void Strike (IDamageable target)
      {
        base.Strike(target); // Extra feature
      }
    }

    public class Bat : Monster
    {
      public Bat (): base ("Bat", 100 ,25 ) {} // Static polymorphism
      public override void Attack (IDamageable target)
      {
        base.Strike(target); // Extra feature
      }
      
    }

    public class Inventory
    {

      private readonly List<Item> items = new List<Item> (); // Dynamic array + supports LINQ + (E*) + "readonly" prevents field from being reassigned

      public void addItem (Item item)
      {

        Debug.Assert (item != null ," Null item CAN NOT be added to inventory! "); // Error handling
        items.Add(item); //stores item in the list
      }

      public bool removeItem (Item item) // bool is used as a data type as the function returns true if the item is successfully removed.
      {
        Debug.Assert(item != null ,"Null item CAN NOT be removed from inventory! "); // Error handling
        return items.removeItem(item); // removes item and returns (true / false).

      }

      // LINQ filter
      public IEnumerable<T> Filter <T>() where T : Item => items.ofType<T>(); // "Generic" + returns only items of the same type of T (T= Item).

      // To find the strongest weapon using LINQ
      public Weapon StongestWeapon()
      {
        var weapon = items.ofType<Weapon>() // 1) Filters weapon instances
                           .OrderByDescendingly(w => w.Damage) // 2) sorts by "Damage" in a descending order
                           .FirstOrDefault(); //Selects the first in the order to be the strongest. 

        Debug.Assert(weapon != null , "No weapons present in inventory! "); // Error handling
        return weapon;                   
      }

      public void NameSort() // Method to alphabetically sort the inventory
      {
        items.Sort((a,b) => string.Compare(a.Name , b.Name, StringComparison.Ordinal)); // Lambda Comparer orders items by their "Name", allowing the player to view the items in a logical order.

      }


    }

    //GameMap class

    public class GameMap
    {
      public List <Room> Rooms {get;} = new List <Room>();//(E*) + read-only + initialisation
      public Room Current {get; private set;}
      private static readonly Randon rng = new Random(); // Can only be changed in this class + can be read other classes

      public GameMap
      {
        // 7 rooms 
        for (int i =1 ; i<=7 ; i++)
        {
          Rooms.Add(new Room ($"Room {i}")); // Loops from rooms 1 to 7 

        }

        //connections
        for (int i = 0; i<6 ; i++) // iterates through the first six rooms and links them together usinf "right" and "left logic.
        {
          Rooms[i].Adjacent["Right"] =Rooms[i+1];// the current room's "Right"  is the next room
          Rooms[i].Adjacent["Left"] = Rooms [i]; // The next room's "Left" is the current room
        }

        Rooms[4].Trap = true; // challenge in room 4

        // Random population of monsters into the rooms
        foreach(var room in Rooms) //iteration over every room in the game
        {
          if ( rng.NextDouble() < 0.5) // 50%  (probability between empty and overcrowded rooms) // Check for monsters // Controls difficulty
          {
            room.Monsters.Add(
                 rng.Next(2) == 0; // returns either 0 or 1  
                 ? (Monster) new Bat()
                 : new Snake()
            );


          }

          if (rng.NextDouble() < 0.3) // Check for items (30% probability) (controls difficulty)
          {
            room.Items.Add(
                 rng.Next(2) == 0
                 ? (Item) new Weapon ("Sword",10);
                 : new Potion ("E", 20);
            );     
          }

        }

        // starting room setting , making sure that at least on room exists.
        Current = Rooms.FirstorDefault();
        Debug.Assert(Current != null ,"At least one room should be there in the map! "); // Error handling


      }

      public void Move (string command)
      {
        Debug.Assert(command != null, "Command CAN NOT be null or empty! "); // Error handling

        if (!Current.Adjacent.TryGetValue(command, out var next)) // Attempt to find an adjacent room in the chosen direction determined by the command.
        {
          throw new InvalidOperationException("This way is in valid! ");
        } 

        Current = next; // goes to the new room
        if (Current.Trap)
        {
          // Trap logic may be added here
          Console.WriteLine("A trap is found , (You lose 10 health points!)");
        }

      }
    }
    
    //Room class (Why is it used ?)
    public class Room
    {
      public string Description {get;}
      public bool Trap {get; set;}
      public List <Monster> Monsters {get;}= new List <Monster>();
      public List <Item> Items {get; } = new List<Item>();
      public Dictionary <string , Room> Adjacent { get; } = new Dictionary<string,Room>();
      
      //Construtor
      public Room (string description)
      {
        Debug.Assert(!string.IsNullOrWhiteSpace(description),"Room description CAN NOT be null or empty!");
        Description = description;
      }
      
    }

    // Binary serialisation persistance
    public static class ManageSaveLoad // Static: (because we don't instantiate this class , instead it groups related functions)
    {
      public static void Save(GameMap map, Player player, string path)
      {
        Debug.Assert(map != null , "To be saved : (Game map) CAN NOT be null !");
        Debug.Assert(player != null , "To be saved: (player) CAN NOT be null !");
        Debug.Assert(!string.IsNullOrWhiteSpace(path), "To be saved: (path) CAN NOT be empty! ");

        try
        {
          using var fs = new FileStream(path, FileMode.Create);
          new BinaryFormatter().Serialze(fs,Tuple.Create(map, player));
        }

        catch (Exception ex)
        {
          Console.WriteLine($"Saving process is unsuccessful :{ex.Message}");

        }
      }
    }

    public static (GameMap ,Player) Load (string path)
    {
      Debug.Assert(!string.IsNullOrWhiteSpace(path), "Path:(Load) CAN NOT be empty! ");

      try
      {
        using var fs = new FileStream(path ,FileMode.Open);
        var tup =(Tuple<GameMap ,Player>) new BinaryFormatter().Deserialize(fs);
        return (tup.Item1 , tup.Item2);

      }

      catch (Exception ex)
      {
        Console.WriteLin($"Loading process id unsuccessful ! :{ex.Message}");
        return(null , null);
      }
    }

    //Items class
    // Abstract class inheriting from the ICollectible interface
    public abstract class Item :ICollectible
    {
      public string Name{get; protected set;}
      public abstract void Collect(Player player);

    }

    public class Weapon : Item
    {
      public int Damage {get;}
      //Constructor
      public Weapon (string name, int damage)
      {
        Debug.Assert(!string.IsNullOrWhiteSpace(name),"Weapon name CAN NOT be empty! ");
        Debug.Assert( damage > 0, "Weapon damage value MUST be POSITIVE!");
        Name = name;
        Damage = damage;
      }

      public overrirde void Collect(Player player)
      {
        Debug.Assert(player != null ,"Player in the game CAN NOT be null !");
        player.Inventory.Add(this);
      }
    }

    public class Potion : Item
    {
      public int Heal {get;}
      //Constructor
      public Potion(string name , int healValue)
      {
        Debug.Assert(!string .IsNullOrWhiteSpace (name),"Name CAN NOT be empty!");
        Debug.Assert(healValue != null , "Value of healing CAN NOT be null!");
        Name = name;
        Heal = healValue;

      }
      public overrirde void Collect(Player player)
      {
        Debug.Assert(player != null ,"Player in the game CAN NOT be null !");
        player.Inventory.Add(this);
      }
    }


    //Main program
    class Program
    {
      static void Main()
      {
        var map = new GameMap();
        var player = new Player();
        Console.WriteLine("Welcome to the Dungeon Explorer game !");

        while (player.Alive)
        {
          Console.WriteLine($"Current Location : {map.Current.Description} Total Score: {player.totalScore} Level: {player.Level}");
          Console.Write("> ");
          var input = Console.ReadLine()?.Split(' ');


          try
          {
            Debug.Assert(input != null && input.Length > 0, "Command input CAN NOT be null (it is required)!");
            var cmd = input[0].ToLower();
            switch (cmd)
            {

              //Case : Move 
              case "move":
              {
                Debug.Assert(input != null && input.Length > 0, "Command input CAN NOT be null (it is required)!");
                map.Move(input[1]);
                break;
                
              }

              //Case : Attack
              case "attack":
              {
                var Monster= map.Current.Monsters.FirstOrDefault();
                Debug.Assert(Monster != null , "No monster present in this room to attack! ");
                player.GainScore(Monster.Health > 50 ? 50 : 20);
                Monster.Damage(player.Level * 5 );
                break;

              }

              // Case "pickup"
              case "pickup":
              {
                Debug.Assert(input.Length > 1 , "An item name is required to be picked up! ");
                var item = map.Current.Items.FirstOrDefault(i = i.Name.Equals(input[1] , StringComparison.OrdinalIgnoreCase));
                Debug.Assert(item != null ."Item is NOT found in the room !");
                item.Collect(player);
                map.Current.Items.Remove(item);
                Console.WriteLine($"Item : {item.Name} has been collected");
                break;
              }

              //Case :Save
              case "save":
              {
                ManageSaveLoad.Save(map, player,"save.dat");
                break;
              }

              //Case :Load
              case "load":
              {
                var state = ManageSaveLoad.Load("save.dat");
                Debug.Assert(state.Item1 != null && state.Item2 != null , "saved state loading process is unsuccessful!");
                map = state.Item1;
                player = state.Item2;
                break;

              }

              //default
              default:
              {
                Console.WriteLine("This command is invalid !");

              }


            }
          }

          catch (Exception ex)
          {
            Console.WriteLine($"Error :{ex.Message}");
          }

          if (player.totalScore >= 500)
          {
            Console.WriteLine("Congratulations ! You won !");
            break;

          }


        }

        if (!player.Alive)
        {
          Console.WriteLine("Hard luck , You died!")
          Console.WriteLine("Game over");
        }
      }
    }



    




}     




     