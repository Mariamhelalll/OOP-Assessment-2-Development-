using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace DungeonExplorer
{


  public static class ProvideRandom
  {
    public static Random Instance {get; } = new Random(); // Initialization
  }
  // Interface (ICollectible) for items

  public interface ICollectible
  {
    string Name {get;}
    void Collect(Player player); //*
  } 

  // Interface (IDamageable) for accepting damage

  public interface IDamageable
  {
    int Health{get; }
    bool _Alive {get; }
    void Damage(int damage);

  } 

  public abstract class Creature : IDamageable
  {
    // Main common properties
    protected int HealthPoints;
    public string Name {get; } // (E) Any part of the code could read the name , but only this class and its subclasses could assign them.
    protected int _health; // (E) (Protected) => visible to the Creature class and its subclasses , but hidden from any irrelevant classes (Ensuring Encapsulation).
    public int Health => HealthPoints; //  (Read-only property)
    public bool _Alive => HealthPoints > 0; //  (Read-only property) , returns true (if health is more than zero).

    // Constructor (Protected) => Can not be initialized , but subclasses could call it via base(...)
    protected Creature (string name, int startingHealth) 
    {
      // Error handling for name entry
      if(string.IsNullOrWhiteSpace(name))
      {
        throw new ArgumentException("Name is required:" , nameof (name));
      }
      if (startingHealth <= 0) 
      {
        throw new ArgumentOutOfRangeException(nameof (startingHealth), "Health MUST be positive!");
      }

      Name = name;
      HealthPoints = startingHealth ; // *initializes the internal "health" field to the passed-in value
    }

    public virtual void Damage (int value) // Virtual => allows subclasses to override this method if they need special "damage" logic.
    {
      if(value < 0) // Ensure damage value is always positive.
      {
        throw new ArgumentOutOfRangeException(nameof (value), "Damge value MUST be positive!");
      }

      HealthPoints = Math.Max(0, HealthPoints - value); // Ensures that no negative points are used.
    }

    // Dynamic polymorphism for different attack behaviours for different monsters
    public abstract void Attack (IDamageable target); // Every concrete subclass MUST implement.
  }

  // Player class 
 public class Player : Creature
  {
    private readonly List<ICollectible> inventory= new();

    public IReadOnlyList<ICollectible> Inventory => inventory;

    public int totalScore {get; private set; } // (E*) Holds player's total points , only methods inside the "Player" class can change it.

    public int Level {get; private set; } // (E*) tracks progression level of player + External alterantion (outside the player class) is NOT possible.

     public int MaximumHealth {get; }

    // Static polymorphism (Overloaded constructers)
    public Player(string name = "Gamer" , int health = 100 , int initialLevel = 1) :base(name, health)
    {
      if (initialLevel < 1)
      {
        throw new ArgumentOutOfRangeException(nameof (initialLevel) , "Level MUST be 1 or more! ");
        
      }
      Level =  initialLevel;
      MaximumHealth = health;

    }

    
       

    // GainScore method ("void" to allow it to be overriden if needed)

    public void GainScore (int result)
    {
      if( result <= 0) 
      {
        throw new ArgumentOutOfRangeException(nameof (result) , "Result value MUST be positive!");
      }
      totalScore += result;
      while (totalScore >= Level *100) // A mechanism used to ensure enough result pints are declared in oreder to move to the next level (current level * 100).
      {
        Level++;
        Console.WriteLine($"Next level : {Level} is achieved !");

      }
    }

    // Attack method (overriden from the base class and replaces the abstract method declaration in the base clase "Creature"). + Uses strongest weapon automatically.
    public override void Attack (IDamageable target)
    {
      if(target == null)
      {
        throw new ArgumentNullException(nameof (target));
      }

      try
      {
        var weapon = inventory.OfType<Weapon>().OrderByDescending(w => w.Damage).First(); //*
        Console.WriteLine($"{Name} is using {weapon.Name} with a value of {weapon.Damage} damage !"); //*
        target.Damage(weapon.Damage);//*
      }

      catch(InvalidOperationException)
      {
        int dmg = Level *5 ;
        Console.WriteLine($"{Name} attacks with a damage value of {dmg}");
        target.Damage(dmg);
      }
 

    }

    public void Heal (int heal)
    {
      if (heal < 0)
      {
        throw new ArgumentOutOfRangeException(nameof (heal) "Heal value MUST be positive! ");

      }
      int past= HealthPoints;
      HealthPoints = Math.Min(MaximumHealth ,HealthPoints + heal);
      Console.WriteLine($"{Name} has healed {HealthPoints - past} points ! Current health: {HealthPoints}/{MaximumHealth} . ");

    }

    public void InventoryAdd(ICollectible item)
    {
      if (item == null)
      {
        throw new ArgumentNullException(nameof (item));

      }
      inventory.Add(item);
    }

    public bool InventoryRemove (ICollectible item) => item != null && inventory.Remove(item);
      
  }

    
  // Monster class
  public abstract class Monster : Creature
  {
    protected int Power {get; }
      
    // Constructer
    protected Monster (string name, int health, int power ) :base (name, health)
    {
      if ( power <= 0) 
      {
        throw new ArgumentOutOfRangeException (nameof(power) ,"Power value MUST be positive !");
        
      }
      Power = power;
    } 


      

    // Attack method from base class "creature"
    public override void Attack (IDamageable target)
    {
      if (target == null )
      {
        throw new ArgumentNullException(nameof (target));
      }
      if (HealthPoints < 0.3 * Power) //30% (special condition for fleeing)
      {
        Console.WriteLine($"{Name} flees !");
      }

      else
      {
        Strike(target);
      }

    } 

    protected virtual void Strike (IDamageable target)
    {
      target.Damage(Power);
      Console.WriteLine($"{Name} has a value of {Power} damage !");
    }

  }

  // Snake Monster
  public class Snake: Monster
  {
    public Snake() : base(" Snake ",30,5 ) { }
    public override void Attack (IDamageable target)
    {
      Console.WriteLine ("Snake strikes with venomous cuspid !");
      base.Attack(target);
    }
  }

  //Bat Monster
  public class Bat : Monster
  {
    public Bat() : base(" Bat ", 100 ,25) { }
    protected override void Strike(IDamageable target)
    {
      Console.WriteLine("Bat cries out and dives in!");
      base.Strike(target);
    }
  } 

  // Goblin Monster
  public class Goblin : Monster
  {
    public Goblin() :base("Goblin" , 60,40) {}
    public overrirde void Attack (IDamageable target)
    {
      Console.WriteLine("Goblin is attacking sneakly! ");
      base.Attack(target);
    }
  }

  // Troll Monster
  public class Troll : Monster
  {
    public Troll (): base ("Troll", 200, 60) {}
    public override void Strike (IDamageable target)
    {
      Console.WriteLine ("Troll's heavy blow smashes everything !");
      base.Strike(target);
    }
  }

  //Items class
  public abstract class Item : ICollectible
  {
    public string Name {get; }
    protected Item (string name)
    {
      if(string.IsNullOrWhiteSpace (name))
      {
        throw new ArgumentException(nameof(name), "Name is required !");
      }
      Name = name ;
    }
    public abstract void Collect (Player player);
  }  

  // Weapon subclass 
  public class Weapon : Item 
  {
    public int Destruction {get; }
    //Constructor
    public Weapon (string name , int destruction): base(name)
    {
      if (destruction <=0 )
      {
        throw new ArgumentOutOfRangeException(nameof(destruction) , "Destruction value MUST be positive! ");
        Destruction = destruction;
      }
    }

    public override void Collect (Player player)
    {
      player.InventoryAdd(this);
      Console.WriteLine($"{player.Name} has picked up {Name} with a damage value of: {Distruction} !");

    }
  }

  // Potion subclass
  public class Potion : Item
  {
    public int AmountOfHealing {get; }
    public Potion (string name , int quantity) : base(name)
    {
      if (quantity <= 0)
      {
        throw new ArgumentOutOfRangeException(nameof(quantity), nameof(quantity));

      }
      AmountOfHealing = quantity;
    }

    public overrirde void Collect (Player player)
    {
      player.InventoryAdd(this);
      Console.WriteLine($"{player.Name} has picked up a potion named {Name} , with a healing value if : {potion.AmountOfHealing} !");
    }

  }

  // Key Item
  public class Key: Item
  {
    public Key (string name): base(name) {}
    public override void Collect (Player player)
    {
      player.InventoryAdd(this);
      Console.WriteLine($"{player.Name} has picked up the {Name} item! ");

    }
  }
  
  // Scroll Item
  public class Scroll :Item
  {
    public string Context {get; }
    public Scroll (string name, string context) :base(name)
    {
      Context = context;

    }

    public override void Collect(Player player)
    {
      player.InventoryAdd(this);
      Console.WriteLine($"{player.Name} has picked up the {Name} item with the context of :{Context}");
    }
  }
  //Debugging 7:35 26/4
  // error fixes 28th 10:32
  //Room and GameMap
  public class Room
  {
    public string Description {get; }
    public bool ContainsTrap {get; set;}
    public bool ContainsPuzzle {get; set;}
    public string QuestionInPuzzle {get; set;}
    public string AnswerOfPuzzle {get; set;}
    public List<Monster> Monsters {get; }= new();
    public List<Item> Items  {get; } = new();
    public Dictionary<string,Room> Adjacent {get; } =new ();

    public Room (string description)
    {
      if (string.IsNullOrWhiteSpace(description))
      {
        throw new ArgumentException(nameof(description), "Description of room is required!");

      }
      Description= description;
    }
  }

  //GameMap  (mechanism)
  public static class GameMapMechanism
  {

    public static GameMap CreateDefault (int totalRooms= 7)
    {

      private static readonly List<string> _descriptions = new List<string>
      {
        "A wet cave with glowing crystals",
        "A messy school library with open books scattered everywhere",
        "A massive hall with the torn walls",
        "" //*
      }
      var rng = ProvideRandom.Instance;
      var rooms = new List <Room>();
      // rooms with descriptions
      for (int i = 0; i < totalRooms ; i++)
      {
        string description = _descriptions[rng.Next(_descriptions.Count)];
        rooms.Add(new Room (description));
      }
      // Linking rooms mechanism
      for (int i = 0 ; i < rooms.Count; i++)
      {
        if (i < rooms.Count - 1) rooms[i].Adjacent[ "Right"] = rooms[i + 1];
        if (i > 0)
        {
          rooms[i].Adjacent["Left"] =  rooms[i-1];
        }
      }

      // Various weapons and potions to be used in rooms
      var weaponList= new List<Weapon>
      {
        new Weapon("Sword" , rng.Next(6,20)),
        new Weapon ("Axe", rng.Next (16, 30)),
        new Weapon ("Dagger" , rng.Next(6,10)),
        new Weapon ("Knife" , rng.Next(3,12))
      };

      var potionList =  new List<Potion>
      {
        new Potion ("Potion: Health" , rng.Next(15,40)),
        new Potion ("Potion: Max" , rng.Next(19,30)),
        new Potion ("Potion : Stamina" , rng.Next(16,50))
      };

      // Population of rooms with monters and items
      foreach (var  room in rooms)
      {
        int monsterCount = rng.Next(0,4);
        for (int n = 0; n < monsterCount; n++)
        {
          Monster m = rng.Next(4) switch
          {
            0 => new Snake(),
            1 => new Bat (),
            2 => new Goblin (),
            _ => new Troll (),
          };
          room.Monsters.Add(m);
        }

        int itemCount = rng.Next(0,4);
        for (n = 0; n < itemCount ; n++)
        {
          Item i = rng.Next(4) switch
          {
            0 => weaponList[rng.Next(weaponList.Count)],
            1 => potionList[rng.Next(potionList.Count)],
            2 => new Key("Golden key");
            _ => new Scroll("Magic Scroll" , "Ask help from a friend to enter!");
          };
          room.Items.Add(i);
        }
      }

      // Special conditions in rooms
      // "Trap" and "Puzzle" 
      if (rooms.Count > 0) rooms[0].ContainsTrap =true;
      if (rooms.Count > 1)
      {
        var presentRoom = rooms[1];
        presentRoom.ContainsPuzzle = true;
        presentRoom.QuestionInPuzzle = "What has hands but can not clap ?";
        presentRoom.AnswerOfPuzzle= "A clock";
      }

      return new GameMap(rooms);
                           
    }
  }

  // GameMap class
  public class GameMap
  {
    public ReadOnlyList<Room> Rooms{get; }
    public Room Present {get; private set; }

    internal GameMap (List<Room> rooms)
    {
      if (rooms == null || rooms.Count == 0)
      {
        throw new ArgumentException ("Rooms are required !", nameof(rooms));
        
      }
      Rooms = rooms;
      Present = rooms[0];

      public void Move (string direction, Player player)
      {
        if (!Present.Adjacent.TryGetValue(direction, out var next))
        {
          throw new InvalidOperationException ("This direction CAN NOT be proceeded with !");

        }

        Present =  next;
        if (Present.ContainsTrap)
        {
          Console.WriteLine ("Oops ! You fell into the trap !");
          Console.WriteLine ("You lose 10 points !");
          player.Damage(10);
          Present.ContainsTrap = false;
        }
      }
    }
  }
 // End debugging 28th 10:42
  // Persistance via (serialization)
  //2:46 27th of april.
  public static class ManageSaveLoad
  {
    private static readonly JsonSerializerOptions Opts = new JsonSerializerOptions
    {
      WriteIntended = true,
      PreferenceHandler = ReferenceHandler.Preserve
    };
    private class State
    {
      public GameMap Map;
      public Player player;
    }

    public static void Save (string route, GameMap map, Player player)
    {
      if (string.IsNullOrWhiteSpace(route)) 
      {
        throw new ArgumentException("Route is required!");

      }
      var s = new State {Map = map, Player = player};
      File.WriteAllText(route , JsonSerializer.Serialize(s, Opts));
    }

    public static (GameMap , Player) Load(string route)
    {
      if (string.IsNullOrWhiteSpace(route))
      {
        throw new ArgumentException ("Route is required!");
      }
      var js = File.ReadAllText(route);
      var st = JsonSerializer.Deserialize<State>(js,Opts) ?? throw new InvalidOperationException ("Deserialization is unsuccessful !");
      return (st.Map , st.player);

    } 



  }

  //Program class
  public static class Program
  {
    private static string Position(GameMap map, Player player1) =>
        $"Position: {map.Present.Description} / Health value: {player1.Health}/ {player1.MaximumHealth} / Total Score: {player1.totalScore} / Level: {player1.Level}";

    private static void Main()
    {
      var map = GameMapMechanism.CreateDefault();
      var player = new Player();

      Console.WriteLine("Welcome to the new adventure in Dungeon Explorer! ");

      while (player._ALive)
      {
        Console.WriteLine(Position(map,player));

        if (map.Present.ContainsPuzzle)
        {
          Console.WriteLine("Here is the puzzle's question : " + map.Present.QuestionInPuzzle);
          Console.Write("Answer:");
          var ans = Console.ReadLine()?Trim().ToLower();
          if (ans == map.Present.AnswerOfPuzzle)
          {
            Console.WriteLine("Well done ! Your answer to the puzzle was correct! ");
            player.GainScore(50);
            map.Present.ContainsPuzzle = false;
          }

          else
          {
            Console.WriteLine("Hard luck ! Your answer to the puzzle is incorrect!(Try again next time!)");
            continue;
          } 
        }

        Console.WriteLine("The order of monster's health sorted descendingly (by health) :");
        map.Present.Monsters
            .OrderByDescending(m => m.Health)
            .ToList()
            .ForEach(m => Console.WriteLine($"{m.Name} : ({m.Health} health points)"));

        Console.WriteLine("Order of Items grouped by type: ");
        map.Present.Items
            .GroupBy(i => i.GetType().Name)
            .ToList()
            .ForEach (g => Console.WriteLine($" {g.Key} : {g.Count()}"));

        Console.Write("Choice: ");
        var input = Console.ReadLine()?.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (input == null || input.Length == 0) continue;

        try
        {
          switch(input[0]. ToLower())
          {
            case "move":
            {
              map.Move(input.Length > 1 ?input[1] : throw new ArgumentException("Direction is required!"));
              break;

            }

            case "attack":
            {
              var monster = map.Present.Monsters.FirstOrDefault() ?? throw new InvalidOperationException("No monsters are present here!");
              player.Attack(monster);
              if(!monster._ALive)
              {
                player.GainScore(monster.Health > 50 ? 50: 20 );
                map.Present.Monsters.Remove(monster);
                Console.WriteLine("Monster is defeated successfully!");
              }
              break;
            }

            case "pickup":
            {
              if(input.Length < 2) throw new ArgumentException("Item name is required!!");
              var item =  map.Present.Items.FirstOrDefault(i => i.Name.Equals(input[1] , StringComparison.OrdinalIgnoreCase))
                          ??  throw new InvalidOperationException ("Item name is not found!");
              item.Collect(player);
              map.Present.Items.Remove(item);
              break;            

            }

            case "use item":
            {
              if (input.Length < 2) throw new ArgumentException(" Item name is required!");
              var potion = player.Inventory.OfType<Potion>()
                  .FirstOrDefault(p => p.Name.Equals(input[1] , StringComparison.OrdinalIgnoreCase))
                         ?? throw new InvalidOperationException ("Potion is NOT in inventory!");
              player.Heal(potion.HealAmount);
              player.InventoryRemove(potion);
              break;           
            }

            case "save":
            {
              ManageSaveLoad.Save("Save.json", map , player);
              Console.WriteLine("Game is saved successfully !");
              break;
            }

            case "load":
            {
              (map, player) = ManageSaveLoad.Load("Save.json");
              Console.WriteLine("Game is loaded successfully");
              break;
            }
            
            case "exit":
            {
              Console.WriteLine("Game exited successfully!");
              break;
            }

            default:
            {
              Console.WriteLine("Invalid input ! (Please try again!)");
              break;
            }
            
          }

          if (player.totalScore >= 600)
          {
            Console.WriteLine("Congratulations ,you won!!");
            break;
          }
        }

        catch (Exception ex)
        {
          Console.WriteLine($"Error is raised :{ex.Message}");
        }        
      }

      if (!player._ALive)
      {
        Console.WriteLine("Unfortunately, you died!");
        Console.WriteLine("Game Over");
      }
    }    

  }

} 


    