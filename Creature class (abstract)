using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace DungeonExplorer
{


  public static class ProvideRandom
  {
    public static Random Instance {get; } = new Random(); // Initialization
  }
  // Interface (ICollectible) for items

  public interface ICollectible
  {
    string Name {get;}
    void Collect(Player player); //*
  } 

  // Interface (IDamageable) for accepting damage

  public interface IDamageable
  {
    int Health{get; }
    bool _Alive {get; }
    void Damage(int damage);

  } 

  public class abstract Creature : IDamageable
  {
    // Main common properties
    protected int HealthPoints;
    public string Name {get; } // (E) Any part of the code could read the name , but only this class and its subclasses could assign them.
    protected int _health; // (E) (Protected) => visible to the Creature class and its subclasses , but hidden from any irrelevant classes (Ensuring Encapsulation).
    public int Health => HealthPoints; //  (Read-only property)
    public bool _ALive => HealthPoints > 0; //  (Read-only property) , returns true (if health is more than zero).

    // Constructor (Protected) => Can not be initialized , but subclasses could call it via base(...)
    protected Creature (string name, int startingHealth) 
    {
      // Error handling for name entry
      if(!string.IsNullOrWhiteSpace(name))
      {
        throw new ArgumentException("Name is required:" , nameof (name));
      }
      if (startingHealth <= 0) 
      {
        throw new ArgumentOutOfRangeException(nameof (startingHealth), "Health MUST be positive!");
      }
      Name = name;
      HealthPoints = startingHealth ; // *initializes the internal "health" field to the passed-in value
    }

    public virtual void Damage (int value) // Virtual => allows subclasses to override this method if they need special "damage" logic.
    {
      if(value < 0) // Ensure damage value is always positive.
      {
        throw new ArgumentOutOfRangeException(nameof (value), "Damge value MUST be positive!");
      }

      HealthPoints = Math.Max(0, HealthPoints - value); // Ensures that no negative points are used.
    }

    // Dynamic polymorphism for different attack behaviours for different monsters
    public abstract void Attack (IDamageable target); // Every concrete subclass MUST implement.
  }

  // Player class 
 public class Player : Creature
  {
    private readonly List<ICollectible> inventory= new();

    public CollectionReadOnly<ICollectible> Inventory => inventory;

    public int totalScore {get; private set; } // (E*) Holds player's total points , only methods inside the "Player" class can change it.

    public int Level {get; private set; } // (E*) tracks progression level of player + External alterantion (outside the player class) is NOT possible.

     public int MaximumHealth {get; }

    // Static polymorphism (Overloaded constructers)
    public Player(string name = "Gamer" , int health = 100 , int initialLevel = 1) :base(name, health)
    {
      if (initialLevel < 1)
      {
        throw new ArgumentOutOfRangeException(nameof (initialLevel) , "Level MUST be 1 or more! ");
        Level =  initialLevel;
        MaximumHealth = health;
      }

    }

    
       

    // GainScore method ("void" to allow it to be overriden if needed)

    public void GainScore (int result)
    {
      if( result <= 0) 
      {
        throw new ArgumentOutOfRangeException(nameof (result) , "Result value MUST be positive!");
      }
      Score += result;
      while (Score >= Level *100) // A mechanism used to ensure enough result pints are declared in oreder to move to the next level (current level * 100).
      {
        Level++;
        Console.WriteLine($"Next level : {Level} is achieved !");

      }
    }

    // Attack method (overriden from the base class and replaces the abstract method declaration in the base clase "Creature"). + Uses strongest weapon automatically.
    public overrirde void Attack (IDamageable target)
    {
      if(target == null)
      {
        throw new ArgumentNullException(nameof (target));
      }

      try
      {
        var weapon = inventory.ofType<Weapon>().OrderByDescending(w => w.Damage).First(); //*
        Console.WriteLine($"{Name} is using {weapon.Name} with a value of {weapon.Damage} damage !"); //*
        target.Damage(weapon.Damage);//*
      }

      catch(InvalidOperationException)
      {
        int dmg = Level *5 ;
        Console.WriteLine($"{Name} attacks with a damage value of {dmg}");
        target.Damage(dmg);
      }
 

    }

    public void Heal (int heal)
    {
      if (heal < 0)
      {
        throw new ArgumentOutOfRangeException(nameof (heal) "Heal value MUST be positive! ");

      }
      int past= HealthPoints;
      HealthPoints = Math.Min(MaximumHealth ,HealthPoints + heal);
      Console.WriteLine($"{Name} has healed {HealthPoints - past} points ! Current health: {HealthPoints}/{MaximumHealth} . ");

    }

    public void InventoryAdd(ICollectible item)
    {
      if (item == null)
      {
        throw new ArgumentNullException(nameof (item));

      }
      inventory.Add(item);
    }

    public bool InventoryRemove (ICollectible item) => item != null && inventory.Remove(item);
      
  }

    
  // Monster class
  public abstract class Monster : Creature
  {
    protected int Power {get; }
      
    // Constructer
    protected Monster (string name, int health, int power ) :base (name, health)
    {
      if ( power <= 0) 
      {
        throw new ArgumentOutOfRangeException (nameof(power) ,"Power value MUST be positive !");
        Power = power;

      }
    } 


      

    // Attack method from base class "creature"
    public override void Attack (IDamageable target)
    {
      if (target == null )
      {
        throw new ArgumentNullException(nameof (target));
      }
      if (HealthPoints < 0.3 * Power) //30% (special condition for fleeing)
      {
        Console.WriteLine($"{Name} flees !");
      }

      else
      {
        Strike(target);
      }

    } 

    protected virtual void Strike (IDamageable target)
    {
      target.Damage(Power);
      Console.WriteLine($"{Name} has a value of {Power} damage !");
    }

  }

  // Snake Monster
  public class Snake: Monster
  {
    public Snake() : base(" Snake ",30,5 ) { }
    public override void Attack (IDamageable target)
    {
      Console.WriteLine ("Snake strikes with venomous cuspid !");
      base.Attack(target);
    }
  }

  //Bat Monster
  public class Bat : Monster
  {
    public Bat() : base(" Bat ", 100 ,25) { }
    protected overrirde void strike(IDamageable target)
    {
      Console.WriteLine("Bat cries out and dives in!");
      base.Strike(target);
    }
  } 

  // Goblin Monster
  public class Goblin : Monster
  {
    public Bat() :base("Goblin" , 60,40) {}
    public overrirde void Attack (IDamageable target)
    {
      Console.WriteLine("Goblin is attacking sneakly! ");
      base.Attack(target);
    }
  }

  // Troll Monster
  public class Troll : Monster
  {
    public Troll (): base ("Troll", 200, 60) {}
    public override void Strike (IDamageable target)
    {
      Console.WriteLine ("Troll's heavy blow smashes everything !");
      base.Strike(target);
    }
  }

  //Items class
  public abstract class Item : ICollectible
  {
    public string Name {get; }
    protected Item (string name)
    {
      if(string.IsNullOrWhiteSpace (name))
      {
        throw new ArgumentException(nameof(name), "Name is required !");
        Name = name ;
      }
    }
    public abstract void Collect (Player player);
  }  

  // Weapon subclass 
  public class Weapon : Item 
  {
    public int Distruction {get; }
    //Constructor
    public Weapon (string name , int distruction): base(name)
    {
      if (distruction <=0 )
      {
        throw new ArgumentOutOfRangeException(nameof(distruction) , "Distruction value MUST be positive! ");
        Distruction = distruction;
      }
    }

    public overrirde void Collect (Player player)
    {
      player.InventoryAdd(this);
      Console.WriteLine($"{player.Name} has picked up {Name} with a damage value of: {Distruction} !");

    }
  }

  // Potion subclass
  public class Potion : Item
  {
    public int AmountOfHealing {get; }
    public Potion (string name , int quantity) : base(name)
    {
      if (quantity <= 0)
      {
        throw new ArgumentOutOfRangeException(nameof(quantity), nameof(quantity));

      }
      AmountOfHealing = quantity;
    }

    public overrirde void Collect (Player player)
    {
      player.InventoryAdd(this);
      Console.WriteLine($"{player.Name} has picked up a potion named {Name} , with a healing value if : {AmountOfHealing} !");
    }

  }

  // Key Item
  public class Key: Item
  {
    public Key (string name): base(name) {}
    public override void Collect (Player player)
    {
      player.InventoryAdd(this);
      Console.WriteLine($"{player.Name} has picked up the {Name} item! ");

    }
  }
  
  // Scroll Item
  public class Scroll :Item
  {
    public string Context {get; }
    public Scroll (string name, string context) :base(name)
    {
      Context = context;

    }

    public override void Collect(Player player)
    {
      player.InventoryAdd(this);
      Console.WriteLine($"{player.Name} has picked up the {Name} item with the context of :{Context}");
    }
  }
  //Debugging 7:35 26/4

  //Room and GameMap
  public class Room
  {
    public string Description {get; }
    public bool ContainsTrap {get; set;}
    public bool ContainsPuzzle {get; set;}
    public string QuestionInPuzzle {get; set;}
    public string AnswerOfPuzzle {get; set;}
    public List<Monster> Monsters {get; }= new();
    public List<Item> Items  {get; } = new();
    public Dictionary<string,Room> Adjacent {get; } =new ();

    public Room (string description)
    {
      if (string.IsNullOrWhiteSpace(description))
      {
        throw new ArgumentException(nameof(description), "Description of room is required!");

      }
      Description= description;
    }
  }

  //GameMap  (mechanism)
  public static class GameMapMechanism
  {

    public static GameMap CreateDefault (int totalRooms= 7)
    {
      var rng = ProvideRandom.Instance;
      var rooms = Enumerable.Range(1 , totalRooms)
                            .Select(i => new Rooms ($"Room {i}"));
                            ToList();
      // Linking rooms mechanism
      for (int i = 0 ; i < rooms.Count; i++)
      {
        if (i < rooms.Count - 1) rooms.Adjacent[ "Right"] = rooms[i + 1];
        if (i > 0)
        {
          rooms[i].Adjacent["Left"] =  rooms[i-1];
        }
      }

      // Various weapons and potions to be used in rooms
      var weaponList= new List<weapon>
      {
        new Weapon("Sword" , rng.Next(6,20)),
        new Weapon ("Axe", rng.Next (16, 30)),
        new Weapon ("Dagger" , rng.Next(10,6)),
        new Weapon ("Knife" , rng.Next(3,12))
      };

      var potionList =  new List<Potion>
      {
        new Potion ("Potion: Health" , rng.Next(15,40)),
        new Potion ("Potion: Max" , rng.Next(19,30)),
        new Potion ("Potion : Stamina" , rng.Next(16,50))
      };

      // Population of rooms with monters and items
      foreach (var in room in rooms)
      {
        int monsterCount = rng.Next(0,4);
        for (int n = 0; n < monsterCount; n++)
        {
          Monster m = rng.Next(4) switch
          {
            0 => new Snake();
            1 => new Bat ();
            2 => new Goblin ();
            _ => new Troll ();
          };
          room.Monsters.Add(m);
        }

        int itemCount = rng.Next(0,4);
        for (n = 0; n < itemCount ; n++)
        {
          Item i = rng.Next(4) switch
          {
            0 => weaponList[rng.Next(weaponList.Count)],
            1 => potionList[rng.Next(potionList.Count)],
            2 => new Key("Golden key");
            _ => new Scroll("Magic Scroll" , "Ask help from a friend to enter!");
          };
          room.Items.Add(i);
        }
      }

      // Special conditions in rooms
      // "Trap" and "Puzzle" 
      if (rooms.Count > 0) rooms[0].ContainsTrap =true;
      if (rooms.Count > 1)
      {
        var presentRoom = rooms[1];
        presentRoom.ContainsPuzzle = true;
        presentRoom.QuestionInPuzzle = "What has hands but can not clap ?";
        presentRoom.AnswerOfPuzzle= "A clock";
      }

      return new GameMap(rooms);
                           
    }
  }

  // GameMap class
  public class GameMap
  {
    public ReadOnlyList<Room> Rooms{get; }
    public Room Present {get; private set; }

    internal GameMap (List<Room> rooms)
    {
      if (rooms == null || rooms.Count == 0)
      {
        throw new ArgumentException ("Rooms are required !", nameof(rooms));
        Rooms = rooms;
        Present = rooms[0];
      }

      public void Move (dtring direction, Player player)
      {
        if (!Present.Adjacent.TryGetValue(direction, out var next))
        {
          throw new InvalidOperationException ("This direction CAN NOT be proceeded with !");

        }

        Present =  next;
        if (Present.HasTrap)
        {
          Console.WriteLine ("Oops ! You fell into the trap !");
          Console.WriteLine ("You lose 10 points !");
          player.Damage(10);
          Present.ContainsTrap = false;
        }
      }
    }
  }

  // Persistance via (serialization)
  //2:46 27th of april.


    public class Inventory
    {

      private readonly List<Item> items = new List<Item> (); // Dynamic array + supports LINQ + (E*) + "readonly" prevents field from being reassigned

      public void addItem (Item item)
      {

        Debug.Assert (item != null ," Null item CAN NOT be added to inventory! "); // Error handling
        items.Add(item); //stores item in the list
      }

      public bool removeItem (Item item) // bool is used as a data type as the function returns true if the item is successfully removed.
      {
        Debug.Assert(item != null ,"Null item CAN NOT be removed from inventory! "); // Error handling
        return items.removeItem(item); // removes item and returns (true / false).

      }

      // LINQ filter
      public IEnumerable<T> Filter <T>() where T : Item => items.ofType<T>(); // "Generic" + returns only items of the same type of T (T= Item).

      // To find the strongest weapon using LINQ
      public Weapon StongestWeapon()
      {
        var weapon = items.ofType<Weapon>() // 1) Filters weapon instances
                           .OrderByDescendingly(w => w.Damage) // 2) sorts by "Damage" in a descending order
                           .FirstOrDefault(); //Selects the first in the order to be the strongest. 

        Debug.Assert(weapon != null , "No weapons present in inventory! "); // Error handling
        return weapon;                   
      }

      public void NameSort() // Method to alphabetically sort the inventory
      {
        items.Sort((a,b) => string.Compare(a.Name , b.Name, StringComparison.Ordinal)); // Lambda Comparer orders items by their "Name", allowing the player to view the items in a logical order.

      }


    }

    //GameMap class

    public class GameMap
    {
      public List <Room> Rooms {get;} = new List <Room>();//(E*) + read-only + initialisation
      public Room Current {get; private set;}
      private static readonly Randon rng = new Random(); // Can only be changed in this class + can be read other classes

      public GameMap
      {
        // 7 rooms 
        for (int i =1 ; i<=7 ; i++)
        {
          Rooms.Add(new Room ($"Room {i}")); // Loops from rooms 1 to 7 

        }

        //connections
        for (int i = 0; i<6 ; i++) // iterates through the first six rooms and links them together usinf "right" and "left logic.
        {
          Rooms[i].Adjacent["Right"] =Rooms[i+1];// the current room's "Right"  is the next room
          Rooms[i].Adjacent["Left"] = Rooms [i]; // The next room's "Left" is the current room
        }

        Rooms[4].Trap = true; // challenge in room 4

        // Random population of monsters into the rooms
        foreach(var room in Rooms) //iteration over every room in the game
        {
          if ( rng.NextDouble() < 0.5) // 50%  (probability between empty and overcrowded rooms) // Check for monsters // Controls difficulty
          {
            room.Monsters.Add(
                 rng.Next(2) == 0; // returns either 0 or 1  
                 ? (Monster) new Bat()
                 : new Snake()
            );


          }

          if (rng.NextDouble() < 0.3) // Check for items (30% probability) (controls difficulty)
          {
            room.Items.Add(
                 rng.Next(2) == 0
                 ? (Item) new Weapon ("Sword",10);
                 : new Potion ("E", 20);
            );     
          }

        }

        // starting room setting , making sure that at least on room exists.
        Current = Rooms.FirstorDefault();
        Debug.Assert(Current != null ,"At least one room should be there in the map! "); // Error handling


      }

      public void Move (string command)
      {
        Debug.Assert(command != null, "Command CAN NOT be null or empty! "); // Error handling

        if (!Current.Adjacent.TryGetValue(command, out var next)) // Attempt to find an adjacent room in the chosen direction determined by the command.
        {
          throw new InvalidOperationException("This way is in valid! ");
        } 

        Current = next; // goes to the new room
        if (Current.Trap)
        {
          // Trap logic may be added here
          Console.WriteLine("A trap is found , (You lose 10 health points!)");
        }

      }
    }
    
    //Room class (Why is it used ?)
    public class Room
    {
      public string Description {get;}
      public bool Trap {get; set;}
      public List <Monster> Monsters {get;}= new List <Monster>();
      public List <Item> Items {get; } = new List<Item>();
      public Dictionary <string , Room> Adjacent { get; } = new Dictionary<string,Room>();
      
      //Construtor
      public Room (string description)
      {
        Debug.Assert(!string.IsNullOrWhiteSpace(description),"Room description CAN NOT be null or empty!");
        Description = description;
      }
      
    }

    // Binary serialisation persistance
    public static class ManageSaveLoad // Static: (because we don't instantiate this class , instead it groups related functions)
    {
      public static void Save(GameMap map, Player player, string path)
      {
        Debug.Assert(map != null , "To be saved : (Game map) CAN NOT be null !");
        Debug.Assert(player != null , "To be saved: (player) CAN NOT be null !");
        Debug.Assert(!string.IsNullOrWhiteSpace(path), "To be saved: (path) CAN NOT be empty! ");

        try
        {
          using var fs = new FileStream(path, FileMode.Create);
          new BinaryFormatter().Serialze(fs,Tuple.Create(map, player));
        }

        catch (Exception ex)
        {
          Console.WriteLine($"Saving process is unsuccessful :{ex.Message}");

        }
      }
    }

    public static (GameMap ,Player) Load (string path)
    {
      Debug.Assert(!string.IsNullOrWhiteSpace(path), "Path:(Load) CAN NOT be empty! ");

      try
      {
        using var fs = new FileStream(path ,FileMode.Open);
        var tup =(Tuple<GameMap ,Player>) new BinaryFormatter().Deserialize(fs);
        return (tup.Item1 , tup.Item2);

      }

      catch (Exception ex)
      {
        Console.WriteLin($"Loading process id unsuccessful ! :{ex.Message}");
        return(null , null);
      }
    }

    //Items class
    // Abstract class inheriting from the ICollectible interface
    public abstract class Item :ICollectible
    {
      public string Name{get; protected set;}
      public abstract void Collect(Player player);

    }

    public class Weapon : Item
    {
      public int Damage {get;}
      //Constructor
      public Weapon (string name, int damage)
      {
        Debug.Assert(!string.IsNullOrWhiteSpace(name),"Weapon name CAN NOT be empty! ");
        Debug.Assert( damage > 0, "Weapon damage value MUST be POSITIVE!");
        Name = name;
        Damage = damage;
      }

      public overrirde void Collect(Player player)
      {
        Debug.Assert(player != null ,"Player in the game CAN NOT be null !");
        player.Inventory.Add(this);
      }
    }

    public class Potion : Item
    {
      public int Heal {get;}
      //Constructor
      public Potion(string name , int healValue)
      {
        Debug.Assert(!string .IsNullOrWhiteSpace (name),"Name CAN NOT be empty!");
        Debug.Assert(healValue != null , "Value of healing CAN NOT be null!");
        Name = name;
        Heal = healValue;

      }
      public overrirde void Collect(Player player)
      {
        Debug.Assert(player != null ,"Player in the game CAN NOT be null !");
        player.Inventory.Add(this);
      }
    }


    //Main program
    class Program
    {
      static void Main()
      {
        var map = new GameMap();
        var player = new Player();
        Console.WriteLine("Welcome to the Dungeon Explorer game !");

        while (player.Alive)
        {
          Console.WriteLine($"Current Location : {map.Current.Description} Total Score: {player.totalScore} Level: {player.Level}");
          Console.Write("> ");
          var input = Console.ReadLine()?.Split(' ');


          try
          {
            Debug.Assert(input != null && input.Length > 0, "Command input CAN NOT be null (it is required)!");
            var cmd = input[0].ToLower();
            switch (cmd)
            {

              //Case : Move 
              case "move":
              {
                Debug.Assert(input != null && input.Length > 0, "Command input CAN NOT be null (it is required)!");
                map.Move(input[1]);
                break;
                
              }

              //Case : Attack
              case "attack":
              {
                var Monster= map.Current.Monsters.FirstOrDefault();
                Debug.Assert(Monster != null , "No monster present in this room to attack! ");
                player.GainScore(Monster.Health > 50 ? 50 : 20);
                Monster.Damage(player.Level * 5 );
                break;

              }

              // Case "pickup"
              case "pickup":
              {
                Debug.Assert(input.Length > 1 , "An item name is required to be picked up! ");
                var item = map.Current.Items.FirstOrDefault(i = i.Name.Equals(input[1] , StringComparison.OrdinalIgnoreCase));
                Debug.Assert(item != null ."Item is NOT found in the room !");
                item.Collect(player);
                map.Current.Items.Remove(item);
                Console.WriteLine($"Item : {item.Name} has been collected");
                break;
              }

              //Case :Save
              case "save":
              {
                ManageSaveLoad.Save(map, player,"save.dat");
                break;
              }

              //Case :Load
              case "load":
              {
                var state = ManageSaveLoad.Load("save.dat");
                Debug.Assert(state.Item1 != null && state.Item2 != null , "saved state loading process is unsuccessful!");
                map = state.Item1;
                player = state.Item2;
                break;

              }

              //default
              default:
              {
                Console.WriteLine("This command is invalid !");

              }


            }
          }

          catch (Exception ex)
          {
            Console.WriteLine($"Error :{ex.Message}");
          }

          if (player.totalScore >= 500)
          {
            Console.WriteLine("Congratulations ! You won !");
            break;

          }


        }

        if (!player.Alive)
        {
          Console.WriteLine("Hard luck , You died!")
          Console.WriteLine("Game over");
        }
      }
    }



    




}     




     