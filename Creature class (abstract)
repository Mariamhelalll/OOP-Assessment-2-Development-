using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using DungeonExplorer;
using System.Runtime.Runtime.Serialization.Formatters.Binary;

namespace DungeonExplorer
{
   // Interface (ICollectible) for items

   public interface ICollectible
   {
    void Use();
   } 

   // Interface (IDamageable) for accepting damage

   public interface IDamageable
    {
     void TakeDamage(int damage)

    } 

   public class abstract Creature : IDamageable
   {
     // Main common properties
     public string name {get;protected set;} // Any part of the code could read the name , but only this class and its subclasses could assign them.
     protected int health; // (E) (Protected) => visible to the Creature class and its subclasses , but hidden from any irrelevant classes (Ensuring Encapsulation).
     public int Health => health; // LINQ expression * (Read-only property)
     public bool ALive => health > 0; // LINQ expression * (Read-only property) , returns true (if health is more than zero).

     // Constructor (Protected) => Can not be initialized , but subclasses could call it via base(...)
     protected Creature (string name, int health) 
     {
       // Error handling for name entry
       Debug.Assert(!string.IsNullOrWhiteSpace(name), "Creature name can not be left empty of null! ");
       Debug.Assert(health > 0 , "Health needs to be positive! "); // Ensures health is always positive.
       Name = name;
       this.health = health; // *initializes the internal "health" field to the passed-in value
     }

     public virtual void Damage (int value) // Virtual => allows subclasses to override this method if they need special "damage" logic.
     {
      Debug.Assert(value >= 0 , "Damage value needs to be positive! "); // Ensure damage value is always positive.
      health = Math.Max(0, health - value); // Ensures that no negative points are used.
     }

     // Dynamic polymorphism for different attack behaviours for different monsters
     public abstract void Attack (Player player); // Every concrete subclass MUST implement.
   }

   // Player class 
   public class Player : Creature
   {
      public Inventory Inventory {get; } = new Inventory();
      public int Score {get; private set; }
      public int Level {get; private set; }

      // Static polymorphism (Overloaded constructers)
      
   }


}     




     