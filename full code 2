using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace DungeonExplorer
{
    //------------------------------------------------------------------------------
    // Utility: Provides a single, shared Random instance to avoid hidden seeding issues
    //------------------------------------------------------------------------------
    public static class RandomProvider
    {
        public static Random Instance { get; } = new Random();
    }

    //------------------------------------------------------------------------------
    // Interface for items that can be collected by the player
    //------------------------------------------------------------------------------
    public interface ICollectible
    {
        string Name { get; }
        void Collect(Player player);
    }

    //------------------------------------------------------------------------------
    // Interface for any entity that can take damage
    //------------------------------------------------------------------------------
    public interface IDamageable
    {
        int Health { get; }
        bool IsAlive { get; }
        void TakeDamage(int amount);
    }

    //------------------------------------------------------------------------------
    // Abstract base class for all creatures (players and monsters)
    //------------------------------------------------------------------------------
    public abstract class Creature : IDamageable
    {
        protected int HealthPoints;
        public string Name { get; }
        public int Health => HealthPoints;
        public bool IsAlive => HealthPoints > 0;

        protected Creature(string name, int initialHealth)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Name must be provided.", nameof(name));
            if (initialHealth <= 0)
                throw new ArgumentOutOfRangeException(nameof(initialHealth), "Health must be positive.");

            Name = name;
            HealthPoints = initialHealth;
        }

        public void TakeDamage(int amount)
        {
            if (amount < 0)
                throw new ArgumentOutOfRangeException(nameof(amount), "Damage must be non-negative.");
            HealthPoints = Math.Max(0, HealthPoints - amount);
        }

        public abstract void Attack(IDamageable target);
    }

    //------------------------------------------------------------------------------
    // Player character
    //------------------------------------------------------------------------------
    public class Player : Creature
    {
        private readonly List<ICollectible> inventory = new();
        public IReadOnlyList<ICollectible> Inventory => inventory;
        public int Score { get; private set; }
        public int Level { get; private set; }
        public int MaxHealth { get; }

        public Player(string name = "Player", int health = 100, int startingLevel = 1)
            : base(name, health)
        {
            if (startingLevel < 1)
                throw new ArgumentOutOfRangeException(nameof(startingLevel), "Level must be at least 1.");
            Level = startingLevel;
            MaxHealth = health;
        }

        public override void Attack(IDamageable target)
        {
            if (target == null)
                throw new ArgumentNullException(nameof(target));
            int damage = Level * 5;
            target.TakeDamage(damage);
            Console.WriteLine($"{Name} attacks for {damage} damage!");
        }

        public void GainScore(int points)
        {
            if (points < 0)
                throw new ArgumentOutOfRangeException(nameof(points), "Points must be non-negative.");
            Score += points;
            while (Score >= Level * 100)
            {
                Level++;
                Console.WriteLine($"Leveled up! You are now level {Level}.");
            }
        }

        public void Heal(int amount)
        {
            if (amount < 0)
                throw new ArgumentOutOfRangeException(nameof(amount), "Heal amount must be non-negative.");
            int prev = HealthPoints;
            HealthPoints = Math.Min(MaxHealth, HealthPoints + amount);
            Console.WriteLine($"{Name} heals for {HealthPoints - prev} points (Health: {HealthPoints}/{MaxHealth}).");
        }

        public void AddToInventory(ICollectible item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));
            inventory.Add(item);
        }

        public bool RemoveFromInventory(ICollectible item) => item != null && inventory.Remove(item);
    }

    //------------------------------------------------------------------------------
    // Monster base class
    //------------------------------------------------------------------------------
    public abstract class Monster : Creature
    {
        protected int Power { get; }

        protected Monster(string name, int health, int power)
            : base(name, health)
        {
            if (power <= 0)
                throw new ArgumentOutOfRangeException(nameof(power), "Power must be positive.");
            Power = power;
        }

        public override void Attack(IDamageable target)
        {
            if (target == null)
                throw new ArgumentNullException(nameof(target));
            if (HealthPoints < 0.2 * Power)
                Console.WriteLine($"{Name} flees!");
            else
                Strike(target);
        }

        protected virtual void Strike(IDamageable target)
        {
            target.TakeDamage(Power);
            Console.WriteLine($"{Name} hits for {Power} damage!");
        }
    }

    public class Snake : Monster
    {
        public Snake() : base("Snake", 30, 5) { }
    }

    public class Bat : Monster
    {
        public Bat() : base("Bat", 100, 25) { }
    }

    //------------------------------------------------------------------------------
    // Items
    //------------------------------------------------------------------------------
    public abstract class Item : ICollectible
    {
        public string Name { get; }
        protected Item(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Name must be provided.", nameof(name));
            Name = name;
        }
        public abstract void Collect(Player player);
    }

    public class Weapon : Item
    {
        public int Damage { get; }
        public Weapon(string name, int damage) : base(name)
        {
            if (damage <= 0)
                throw new ArgumentOutOfRangeException(nameof(damage), "Damage must be positive.");
            Damage = damage;
        }
        public override void Collect(Player player)
        {
            player.AddToInventory(this);
            Console.WriteLine($"{player.Name} picked up {Name} (Damage: {Damage}).");
        }
    }

    public class Potion : Item
    {
        public int HealAmount { get; }
        public Potion(string name, int amount) : base(name)
        {
            if (amount <= 0)
                throw new ArgumentOutOfRangeException(nameof(amount), nameof(amount));
            HealAmount = amount;
        }
        public override void Collect(Player player)
        {
            player.AddToInventory(this);
            Console.WriteLine($"{player.Name} picked up {Name} (Heals: {HealAmount}).");
        }
    }

    //------------------------------------------------------------------------------
    // Rooms and map
    //------------------------------------------------------------------------------
    public class Room
    {
        public string Description { get; }
        public bool HasTrap { get; set; }
        public List<Monster> Monsters { get; } = new();
        public List<Item> Items { get; } = new();
        public Dictionary<string, Room> Adjacent { get; } = new();

        public Room(string desc)
        {
            if (string.IsNullOrWhiteSpace(desc))
                throw new ArgumentException("Description required.", nameof(desc));
            Description = desc;
        }
    }

    public static class GameMapFactory
    {
        public static GameMap CreateDefault(int count = 7)
        {
            var rng = RandomProvider.Instance;
            var rooms = Enumerable.Range(1, count)
                                  .Select(i => new Room($"Room {i}"))
                                  .ToList();
            for (int i = 0; i < rooms.Count - 1; i++)
            {
                rooms[i].Adjacent["Right"] = rooms[i + 1];
                rooms[i + 1].Adjacent["Left"] = rooms[i];
            }
            foreach (var room in rooms)
            {
                if (rng.NextDouble() < 0.5)
                    room.Monsters.Add(rng.Next(2) == 0 ? new Bat() : new Snake());
                if (rng.NextDouble() < 0.3)
                    room.Items.Add(rng.Next(2) == 0
                        ? (Item)new Weapon("Sword", 10)
                        : new Potion("Health Potion", 20));
            }
            if (rooms.Count > 3)
                rooms[3].HasTrap = true;
            return new GameMap(rooms);
        }
    }

    public class GameMap
    {
        public IReadOnlyList<Room> Rooms { get; }
        public Room Current { get; private set; }

        internal GameMap(List<Room> rooms)
        {
            if (rooms == null || rooms.Count == 0)
                throw new ArgumentException("Rooms required.", nameof(rooms));
            Rooms = rooms;
            Current = rooms[0];
        }

        public void Move(string dir, Player player)
        {
            if (!Current.Adjacent.TryGetValue(dir, out var next))
                throw new InvalidOperationException("Cannot move in that direction.");
            Current = next;
            if (Current.HasTrap)
            {
                Console.WriteLine("You triggered a trap and lose 10 health!");
                player.TakeDamage(10);
            }
        }
    }

    //------------------------------------------------------------------------------
    // Persistence
    //------------------------------------------------------------------------------
    public static class SaveLoadManager
    {
        private static readonly JsonSerializerOptions Options = new JsonSerializerOptions
        {
            WriteIndented = true,
            ReferenceHandler = ReferenceHandler.Preserve
        };

        private class State { public GameMap Map; public Player Player; }

        public static void Save(string path, GameMap map, Player player)
        {
            if (string.IsNullOrWhiteSpace(path))
                throw new ArgumentException("Path required.", nameof(path));
            var state = new State { Map = map, Player = player };
            File.WriteAllText(path, JsonSerializer.Serialize(state, Options));
        }

        public static (GameMap, Player) Load(string path)
        {
            if (string.IsNullOrWhiteSpace(path))
                throw new ArgumentException("Path required.", nameof(path));
            var json = File.ReadAllText(path);
            var st = JsonSerializer.Deserialize<State>(json, Options)
                     ?? throw new InvalidDataException("Deserialization failed.");
            return (st.Map, st.Player);
        }
    }

    //------------------------------------------------------------------------------
    // Program entry point
    //------------------------------------------------------------------------------
    public static class Program
    {
        private static string StatusLine(GameMap map, Player player) =>
            $"Location: {map.Current.Description} | Health: {player.Health}/{player.MaxHealth} | Score: {player.Score} | Level: {player.Level}";

        public static void Main()
        {
            var map = GameMapFactory.CreateDefault();
            var player = new Player();
            Console.WriteLine("Welcome to Dungeon Explorer!");
            while (player.IsAlive)
            {
                Console.WriteLine(StatusLine(map, player));
                Console.WriteLine("Monsters: " + string.Join(", ", map.Current.Monsters.Select(m => $"{m.Name}({m.Health})")));
                Console.WriteLine("Items: " + string.Join(", ", map.Current.Items.Select(i => i.Name)));
                Console.Write("> ");
                var input = Console.ReadLine()?.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                if (input == null || input.Length == 0) continue;
                try
                {
                    var cmd = input[0].ToLower();
                    switch (cmd)
                    {
                        case "move": map.Move(input.Length>1?input[1]:throw new ArgumentException("Direction required."), player); break;
                        case "attack":
                            var mon = map.Current.Monsters.FirstOrDefault() ?? throw new InvalidOperationException("No monster here.");
                            player.Attack(mon);
                            if (!mon.IsAlive)
                            {
                                player.GainScore(mon.Health>50?50:20);
                                map.Current.Monsters.Remove(mon);
                                Console.WriteLine("Monster defeated!");
                            }
                            break;
                        case "pickup":
                            if (input.Length<2) throw new ArgumentException("Item name required.");
                            var itm = map.Current.Items.FirstOrDefault(i=>i.Name.Equals(input[1],StringComparison.OrdinalIgnoreCase))
                                      ?? throw new InvalidOperationException("Item not found.");
                            itm.Collect(player); map.Current.Items.Remove(itm);
                            break;
                        case "use":
                            if (input.Length<2) throw new ArgumentException("Item name required.");
                            var pot = player.Inventory.OfType<Potion>().FirstOrDefault(p=>p.Name.Equals(input[1],StringComparison.OrdinalIgnoreCase))
                                      ?? throw new InvalidOperationException("Potion not in inventory.");
                            player.Heal(pot.HealAmount); player.RemoveFromInventory(pot);
                            break;
                        case "save": SaveLoadManager.Save("save.json",map,player); Console.WriteLine("Game saved."); break;
                        case "load": (map,player)=SaveLoadManager.Load("save.json"); Console.WriteLine("Game loaded."); break;
                        case "exit": Console.WriteLine("Exiting game."); return;
                        default: Console.WriteLine("Unknown command."); break;
                    }
                    if (player.Score>=500) { Console.WriteLine("Congratulations, you won!"); break; }
                }
                catch(Exception ex)
                {
                    Console.WriteLine($"Error: {ex.Message}");
                }
            }
            if (!player.IsAlive) Console.WriteLine("You died! Game Over.");
        }
    }
}
