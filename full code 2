using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace DungeonExplorer
{
    //------------------------------------------------------------------------------
    // Utility: Provides a single, shared Random instance to avoid hidden seeding issues
    //------------------------------------------------------------------------------
    public static class RandomProvider
    {
        public static Random Instance { get; } = new Random();
    }

    //------------------------------------------------------------------------------
    // Interface for items that can be collected by the player
    //------------------------------------------------------------------------------
    public interface ICollectible
    {
        string Name { get; }
        void Collect(Player player);
    }

    //------------------------------------------------------------------------------
    // Interface for any entity that can take damage
    //------------------------------------------------------------------------------
    public interface IDamageable
    {
        int Health { get; }
        bool IsAlive { get; }
        void TakeDamage(int amount);
    }

    //------------------------------------------------------------------------------
    // Abstract base class for all creatures (players and monsters)
    //------------------------------------------------------------------------------
    public abstract class Creature : IDamageable
    {
        protected int _health;
        public string Name { get; }
        public int Health => _health;
        public bool IsAlive => _health > 0;

        protected Creature(string name, int initialHealth)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Name must be provided.", nameof(name));
            if (initialHealth <= 0)
                throw new ArgumentOutOfRangeException(nameof(initialHealth), "Health must be positive.");

            Name = name;
            _health = initialHealth;
        }

        public virtual void TakeDamage(int amount)
        {
            if (amount < 0)
                throw new ArgumentOutOfRangeException(nameof(amount), "Damage must be non-negative.");

            _health = Math.Max(0, _health - amount);
        }

        public abstract void Attack(IDamageable target);
    }

    //------------------------------------------------------------------------------
    // Represents the player character
    //------------------------------------------------------------------------------
    public class Player : Creature
    {
        private readonly List<ICollectible> _inventory = new();
        private readonly int _maxHealth;

        public IReadOnlyCollection<ICollectible> Inventory => _inventory.AsReadOnly();
        public int Score { get; private set; }
        public int Level { get; private set; }
        public int MaxHealth => _maxHealth;

        public Player(string name = "Player", int health = 100, int startingLevel = 1)
            : base(name, health)
        {
            if (startingLevel < 1)
                throw new ArgumentOutOfRangeException(nameof(startingLevel), "Level must be at least 1.");

            Level = startingLevel;
            _maxHealth = health;
        }

        public override void Attack(IDamageable target)
        {
            if (target == null)
                throw new ArgumentNullException(nameof(target));

            int damage = Level * 5;
            target.TakeDamage(damage);
            Console.WriteLine($"{Name} attacks for {damage} damage!");
        }

        public void GainScore(int points)
        {
            if (points < 0)
                throw new ArgumentOutOfRangeException(nameof(points), "Points must be non-negative.");

            Score += points;
            while (Score >= Level * 100)
            {
                Level++;
                Console.WriteLine($"Leveled up! You are now level {Level}.");
            }
        }

        public void Heal(int amount)
        {
            if (amount < 0)
                throw new ArgumentOutOfRangeException(nameof(amount), "Heal amount must be non-negative.");

            int oldHealth = _health;
            _health = Math.Min(_maxHealth, _health + amount);
            Console.WriteLine($"{Name} heals for {_health - oldHealth} points (Health: {_health}/{_maxHealth}).");
        }

        public void AddToInventory(ICollectible item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));
            _inventory.Add(item);
        }

        public bool RemoveFromInventory(ICollectible item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));
            return _inventory.Remove(item);
        }

        public IEnumerable<T> InventoryItemsOfType<T>() where T : ICollectible
            => _inventory.OfType<T>();

        public Weapon GetStrongestWeapon()
        {
            return InventoryItemsOfType<Weapon>()
                   .OrderByDescending(w => w.Damage)
                   .FirstOrDefault()
                ?? throw new InvalidOperationException("No weapons in inventory.");
        }
    }

    //------------------------------------------------------------------------------
    // Abstract monster base class
    //------------------------------------------------------------------------------
    public abstract class Monster : Creature
    {
        protected int Power { get; }

        protected Monster(string name, int health, int power)
            : base(name, health)
        {
            if (power <= 0)
                throw new ArgumentOutOfRangeException(nameof(power), "Power must be positive.");
            Power = power;
        }

        public override void Attack(IDamageable target)
        {
            if (target == null)
                throw new ArgumentNullException(nameof(target));

            if (Health < 0.2 * Power)
                Console.WriteLine($"{Name} flees!");
            else
                Strike(target);
        }

        public virtual void Strike(IDamageable target)
        {
            target.TakeDamage(Power);
            Console.WriteLine($"{Name} hits for {Power} damage!");
        }
    }

    public class Snake : Monster
    {
        public Snake() : base("Snake", 30, 5) { }

        public override void Strike(IDamageable target)
        {
            base.Strike(target);
        }
    }

    public class Bat : Monster
    {
        public Bat() : base("Bat", 100, 25) { }
    }

    //------------------------------------------------------------------------------
    // Abstract base for items
    //------------------------------------------------------------------------------
    public abstract class Item : ICollectible
    {
        public string Name { get; }

        protected Item(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Name must be provided.", nameof(name));
            Name = name;
        }

        public abstract void Collect(Player player);
    }

    public class Weapon : Item
    {
        public int Damage { get; }

        public Weapon(string name, int damage) : base(name)
        {
            if (damage <= 0)
                throw new ArgumentOutOfRangeException(nameof(damage), "Damage must be positive.");
            Damage = damage;
        }

        public override void Collect(Player player)
        {
            player.AddToInventory(this);
            Console.WriteLine($"{player.Name} picked up {Name} (Damage: {Damage}).");
        }
    }

    public class Potion : Item
    {
        public int HealAmount { get; }

        public Potion(string name, int healAmount) : base(name)
        {
            if (healAmount <= 0)
                throw new ArgumentOutOfRangeException(nameof(healAmount), nameof(healAmount));
            HealAmount = healAmount;
        }

        public override void Collect(Player player)
        {
            player.AddToInventory(this);
            Console.WriteLine($"{player.Name} picked up {Name} (Heals: {HealAmount}).");
        }
    }

    //------------------------------------------------------------------------------
    // Room with linked navigation
    //------------------------------------------------------------------------------
    public class Room
    {
        public string Description { get; }
        public bool HasTrap { get; set; }
        public List<Monster> Monsters { get; } = new();
        public List<Item> Items { get; } = new();
        public Dictionary<string, Room> Adjacent { get; } = new();

        public Room(string description)
        {
            if (string.IsNullOrWhiteSpace(description))
                throw new ArgumentException("Description must be provided.", nameof(description));
            Description = description;
        }
    }

    //------------------------------------------------------------------------------
    // GameMap only handles navigation
    //------------------------------------------------------------------------------
    public class GameMap
    {
        public IReadOnlyList<Room> Rooms { get; }
        public Room Current { get; private set; }

        internal GameMap(List<Room> rooms)
        {
            if (rooms == null || rooms.Count == 0)
                throw new ArgumentException("Must supply at least one room.", nameof(rooms));
            Rooms = rooms;
            Current = rooms[0];
        }

        public void Move(string direction, Player player)
        {
            if (direction == null)
                throw new ArgumentNullException(nameof(direction));
            if (!Current.Adjacent.TryGetValue(direction, out var next))
                throw new InvalidOperationException("Cannot move in that direction.");

            Current = next;
            if (Current.HasTrap)
            {
                Console.WriteLine("You triggered a trap and lose 10 health!");
                player.TakeDamage(10);
            }
        }
    }

    //------------------------------------------------------------------------------
    // Decoupled factory for map generation
    //------------------------------------------------------------------------------
    public static class GameMapFactory
    {
        public static GameMap CreateDefault(int roomCount = 7)
        {
            var rng = RandomProvider.Instance;
            var rooms = new List<Room>();
            for (int i = 1; i <= roomCount; i++)
                rooms.Add(new Room($"Room {i}"));

            for (int i = 0; i < rooms.Count - 1; i++)
            {
                rooms[i].Adjacent["Right"] = rooms[i + 1];
                rooms[i + 1].Adjacent["Left"] = rooms[i];
            }

            foreach (var room in rooms)
            {
                if (rng.NextDouble() < 0.5)
                    room.Monsters.Add(rng.Next(2) == 0 ? new Bat() : new Snake());
                if (rng.NextDouble() < 0.3)
                    room.Items.Add(rng.Next(2) == 0
                        ? (Item)new Weapon("Sword", 10)
                        : new Potion("Health Potion", 20));
            }

            if (rooms.Count >= 4)
                rooms[3].HasTrap = true;

            return new GameMap(rooms);
        }
    }

    //------------------------------------------------------------------------------
    // Manages save/load to JSON with reference preservation
    public static class SaveLoadManager
    {
        private static readonly JsonSerializerOptions Options = new()
        {
            WriteIndented = true,
            ReferenceHandler = ReferenceHandler.Preserve
        };

        private class GameState
        {
            public GameMap Map { get; set; }
            public Player Player { get; set; }
        }

        /// <summary>
        /// Saves the current map and player state to the specified file path.
        /// </summary>
        public static void Save(string path, GameMap map, Player player)
        {
            if (string.IsNullOrWhiteSpace(path))
                throw new ArgumentException("Path required.", nameof(path));
            if (map == null)
                throw new ArgumentNullException(nameof(map));
            if (player == null)
                throw new ArgumentNullException(nameof(player));

            var state = new GameState { Map = map, Player = player };
            File.WriteAllText(path, JsonSerializer.Serialize(state, Options));
        }

        /// <summary>
        /// Loads and reconstructs map and player from the given JSON file.
        /// </summary>
        public static (GameMap Map, Player Player) Load(string path)
        {
            if (string.IsNullOrWhiteSpace(path))
                throw new ArgumentException("Path required.", nameof(path));

            var json = File.ReadAllText(path);
            var state = JsonSerializer.Deserialize<GameState>(json, Options)
                        ?? throw new InvalidDataException("Could not deserialize game state.");

            return (state.Map, state.Player);
        }
    }

    //------------------------------------------------------------------------------
    // Program entry point: handles console UI and main game loop
    //------------------------------------------------------------------------------
    public static class Program
    {
        public static void Main()
        {
            var map = GameMapFactory.CreateDefault();
            var player = new Player();

            Console.WriteLine("Welcome to Dungeon Explorer!");

            while (player.IsAlive)
            {
                Console.WriteLine($"
Location: {map.Current.Description} | Health: {player.Health}/{player.MaxHealth} | Score: {player.Score} | Level: {player.Level}");
                Console.WriteLine("Monsters: " + string.Join(", ", map.Current.Monsters.Select(m => m.Name + "(" + m.Health + ")")));
                Console.WriteLine("Items: " + string.Join(", ", map.Current.Items.Select(i => i.Name)));
                Console.Write("> ");
                var input = Console.ReadLine()?.Split(' ', StringSplitOptions.RemoveEmptyEntries);
                if (input == null || input.Length == 0)
                    continue;

                try
                {
                    var command = input[0].ToLower();
                    switch (command)
                    {
                        case "move":
                            map.Move(input.Length > 1 ? input[1] : throw new ArgumentException("Direction required."), player);
                            break;
                        case "attack":
                            var monster = map.Current.Monsters.FirstOrDefault()
                                          ?? throw new InvalidOperationException("No monster here.");
                            player.Attack(monster);
                            if (!monster.IsAlive)
                            {
                                player.GainScore(monster.Health > 50 ? 50 : 20);
                                map.Current.Monsters.Remove(monster);
                                Console.WriteLine("Monster defeated!");
                            }
                            break;
                        case "pickup":
                            if (input.Length < 2)
                                throw new ArgumentException("Item name required.");
                            var item = map.Current.Items
                                .FirstOrDefault(i => i.Name.Equals(input[1], StringComparison.OrdinalIgnoreCase))
                                       ?? throw new InvalidOperationException("Item not found.");
                            item.Collect(player);
                            map.Current.Items.Remove(item);
                            break;
                        case "use":
                            if (input.Length < 2)
                                throw new ArgumentException("Item name required.");
                            var useItem = player.Inventory
                                .OfType<Potion>()
                                .FirstOrDefault(p => p.Name.Equals(input[1], StringComparison.OrdinalIgnoreCase))
                                       ?? throw new InvalidOperationException("Potion not in inventory.");
                            player.Heal(useItem.HealAmount);
                            player.RemoveFromInventory(useItem);
                            break;
                        case "save":
                            SaveLoadManager.Save("save.json", map, player);
                            Console.WriteLine("Game saved.");
                            break;
                        case "load":
                            (map, player) = SaveLoadManager.Load("save.json");
                            Console.WriteLine("Game loaded.");
                            break;
                        case "exit":
                            Console.WriteLine("Exiting game.");
                            return;
                        default:
                            Console.WriteLine("Unknown command.");
                            break;
                    }

                    if (player.Score >= 500)
                    {
                        Console.WriteLine("Congratulations, you won!");
                        break;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error: {ex.Message}");
                }
            }

            if (!player.IsAlive)
                Console.WriteLine("You died! Game Over.");
        }
    }
}
