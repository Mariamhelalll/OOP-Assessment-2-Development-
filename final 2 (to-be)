using System;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Net.Http.Json;
using System.Xml;

namespace DungeonExplorer
{
    ///<summary>
    /// Consistent randomisation innstance (which provides a single and shared <see cref="Random"/>)
    /// Attributes:
    ///   - Instance: Random {static + read-only)
    /// </summary>

    public static class ProvideRandom
    {
        /// <summary>
        /// Singleton <see cref="Random"/> instance is acheived.
        /// </summary>

        public static Random Instance { get; } = new Random();
    }

    ///<summary>
    /// Representation of an item to be collected by <see cref="Player"/>.
    ///Attributes:
    ///   = Name: string {read-only}
    /// Operations:
    ///   = Collect(player: Player): void
    /// </summary>

    public interface ICollectible
    {
        string Name { get; }
        void Collect(Player player);
    }

    ///<summary>
    /// Representation of an object that can accept damage and tracks its health
    ///  Attributes:
    ///   = Health: int {read-only}
    ///   = _Alive: bool {read-only}
    /// Operations:
    ///   = Damage(damage: int): void
    /// </summary>

    public interface IDamageable
    {
        int Health { get; }
        bool _Alive { get; }
        void Damage(int damage);
    }

    ///<summary>
    /// Base class for creatures, which handles health tracking and attacks
    ///  <<abstract>> Creature
    /// Attributes:
    ///   = HealthPoints: int {protected}
    ///   = Name: string {read-only}
    ///   = Health: int {read-only}
    ///   = _Alive: bool {read-only}
    /// Operations:
    ///   = Damage(value: int): void
    ///   = Attack(target: IDamageable): void {abstract}
    /// </summary>

    public abstract class Creature : IDamageable
    {
        protected int HealthPoints;
        public string Name { get; }
        public int Health => HealthPoints;
        public bool _Alive => HealthPoints > 0;

        /// <summary>
        /// initialzes a new "Creature" with a starting health and a name (constructor).
        /// </summary>
        
        protected Creature(string name, int startingHealth)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Name is required:", nameof(name)); // Error handling for name
            if (startingHealth <= 0)
                throw new ArgumentOutOfRangeException(nameof(startingHealth), "Health MUST be positive!"); // Error handling for health

            Name = name;
            HealthPoints = startingHealth;
        }

        ///<summary>
        /// Damage class which handles damage value
        /// </summary>
        public virtual void Damage(int value)
        {
            if (value < 0)
                throw new ArgumentOutOfRangeException(nameof(value), "Damage value MUST be positive!"); //Error handling(must be positive integer).
            HealthPoints = Math.Max(0, HealthPoints - value);//Use of statistics class (Math.Max) to calculate the final total of health points.
        }

        ///<summary>
        /// A method to initiate an attack on the target.
        /// </summary>
        public abstract void Attack(IDamageable target);


    }

    ///<summary>
    /// The player class inherits its features from the base class "Creature" , in addition to adding the inventory, scoring scheme, leveling logic and combats.
    /// </summary>

    public class Player : Creature
    {
        private readonly List<ICollectible> inventory = new();
        public IReadOnlyList<ICollectible> Inventory => inventory;
        public int totalScore { get;  set; }
        public int Level { get;  set; }
        public int MaximumHealth { get;  set; }


        public Player() : base ("Gamer" ,100)
        {
            totalScore = 0;
            Level = 1;
            MaximumHealth = 100;
        }

        ///<summary>
        ///constructor creating a player's name, health and current level status.
        /// </summary>

        public Player(string name = "Gamer", int health = 100, int initialLevel = 1) : base(name, health)
        {
            if (initialLevel < 1)
                throw new ArgumentOutOfRangeException(nameof(initialLevel), "Level MUST be 1 or more!");
            Level = initialLevel;
            MaximumHealth = health;
        }

        ///<summary>
        /// A method which adds up the total score and levels up when  the threshold : (totalScore >= Level * 100) , is acheived.
        /// </summary>

        public void GainScore(int result)
        {
            if (result <= 0)
                throw new ArgumentOutOfRangeException(nameof(result), "Result value MUST be positive!");

            totalScore += result;
            while (totalScore >= Level * 100)
            {
                Level++;
                MaximumHealth += 30;
                HealthPoints = MaximumHealth;
                Console.WriteLine($"Next level: {Level} is achieved!");
            }
        }
        ///<summary>
        /// Example of dynamic polymorphism: implements its own logic.
        /// </summary>
        /// 
        public override void Attack(IDamageable target)
        {
            if (target == null)
                throw new ArgumentNullException(nameof(target));
            // Use of best weapon trial, if not, base class's damage logic is applied.
            try
            {
                var weapon = inventory.OfType<Weapon>().OrderByDescending(w => w.Damage).First();
                Console.WriteLine($"{Name} attacks with {weapon.Name} ({weapon.Damage} damage)!");
                target.Damage(weapon.Damage);
            }
            catch (InvalidOperationException)
            {
                int dmg = Level * 5;
                Console.WriteLine($"{Name} attacks with {dmg} base damage!");
                target.Damage(dmg);
            }
        }

        ///<summary>
        ///  heals the health vakue to the maximum health possible.
        /// </summary>

        public void Heal(int heal)
        {
            if (heal < 0)
                throw new ArgumentOutOfRangeException(nameof(heal), "Heal value MUST be positive!");

            int previous = HealthPoints;
            HealthPoints = Math.Min(MaximumHealth, HealthPoints + heal);
            Console.WriteLine($"{Name} healed {HealthPoints - previous} points! ({HealthPoints}/{MaximumHealth})");
        }

        ///<summary>
        /// method to add item to inventory
        /// </summary>

        public void InventoryAdd(ICollectible item)
        {
            if (item == null)
                throw new ArgumentNullException(nameof(item));
            inventory.Add(item);
        }

        ///<summary>
        /// method to remove item from inventory
        /// </summary>
        public bool InventoryRemove(ICollectible item) => item != null && inventory.Remove(item);
    }

    ///<summary>
    /// A base class for all monsters, with varying strength and a feature of fleeing logic.
    /// </summary>

    public abstract class Monster : Creature
    {
        protected int Power { get; }

        //initializes a monster's name, health and power.
        protected Monster(string name, int health, int power) : base(name, health)
        {
            if (power <= 0)
                throw new ArgumentOutOfRangeException(nameof(power), "Power MUST be positive!"); // Error handling
            Power = power;
        }

        // Dynamic polymorphism : A fleeing fearure logic is applied when 30% of the monster's strength is acheived.
        public override void Attack(IDamageable target)
        {
            if (target == null)
                throw new ArgumentNullException(nameof(target));

            if (HealthPoints < 0.3 * Power)
            {
                Console.WriteLine($"{Name} flees!");
            }
            else
            {
                Strike(target);
            }
        }

        ///<summary>
        /// A method defining the default strike behaviour
        /// </summary>

        protected virtual void Strike(IDamageable target)
        {
            Console.WriteLine($"{Name} strikes with {Power} power!");
            target.Damage(Power);
        }

        public void DoStrike(IDamageable target) => Strike(target);
    }

    // Snake monster
    public class Snake : Monster
    {
        //Constructor
        public Snake() : base("Snake", 30, 20) { }

        // Applies a specific attack  when in action .
        public override void Attack(IDamageable target)
        {
            Console.WriteLine("Snake strikes with venomous fangs!");
            base.Attack(target);
        }
    }

    // Bat monster
    public class Bat : Monster
    {
        //Constructor
        public Bat() : base("Bat", 100, 25) { }

        //Applies a specific strike when in action .
        protected override void Strike(IDamageable target)
        {
            Console.WriteLine("Bat screeches and attacks!");
            base.Strike(target);
        }
    }

    // Goblin monster
    public class Goblin : Monster
    {
        //Constructor
        public Goblin() : base("Goblin", 60, 40) { }

        // Applies a specific attack when in action.
        public override void Attack(IDamageable target)
        {
            Console.WriteLine("Goblin attacks sneakily!");
            base.Attack(target);
        }
    }

    //Troll monster
    public class Troll : Monster
    {
        //Constructor
        public Troll() : base("Troll", 200, 60) { }

        //Applies a specific strike when in action.
        protected override void Strike(IDamageable target)
        {
            Console.WriteLine("Troll smashes heavily!");
            base.Strike(target);
        }
    }

    //Item abstract class with subclasses branching from it which inherits its features.
    // Sets name of item 
    public abstract class Item : ICollectible
    {
        public string Name { get; }

        protected Item(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                throw new ArgumentException("Name is required!", nameof(name)); // Error handling
            Name = name;
        }
        // Method to collect items.
        public abstract void Collect(Player player);
    }

    // Weapon subclass (creates a weapon with its name and damage value).
    public class Weapon : Item
    {
        public int Damage { get; }

        //Constructor 
        public Weapon(string name, int damage) : base(name)
        {
            if (damage <= 0)
                throw new ArgumentOutOfRangeException(nameof(damage), "Damage MUST be positive!"); //Error handling
            Damage = damage;
        }

        //Applying "Collect" method logic. (Dynamic polymorohism).
        public override void Collect(Player player)
        {
            player.InventoryAdd(this);
            Console.WriteLine($"{player.Name} picked up {Name} ({Damage} damage)!");
        }
    }

    //Potion subclass (Sets potion's name and healing value).
    public class Potion : Item
    {
        public int AmountOfHealing { get; }

        //Constructor
        public Potion(string name, int quantity) : base(name)
        {
            if (quantity <= 0)
                throw new ArgumentOutOfRangeException(nameof(quantity), "Quantity must be positive!"); // Error handling
            AmountOfHealing = quantity;
        }
        // Dynamic polymorphism (Applying "Collect" method logic with overriding).
        public override void Collect(Player player)
        {
            player.InventoryAdd(this);
            Console.WriteLine($"{player.Name} picked up {Name} (heals {AmountOfHealing})!");
        }
    }

    // Key subclass
    public class Key : Item
    {
        //Constructor
        public Key(string name) : base(name) { }

        //Dynamic polymorphism (Applying "Collect" method logic with overriding).
        public override void Collect(Player player)
        {
            player.InventoryAdd(this);
            Console.WriteLine($"{player.Name} picked up the {Name}!");
        }
    }

    //Scroll subclass
    public class Scroll : Item
    {
        public string Context { get; }

        //Constructor
        public Scroll(string name, string context) : base(name)
        {
            Context = context;
        }

        //Dynamic polymorphism (Applying "Collect" method logic with overriding).
        public override void Collect(Player player)
        {
            player.InventoryAdd(this);
            Console.WriteLine($"{player.Name} found {Name}: {Context}");
        }
    }

    public class Room
    {
        public string Description { get; }
        public bool ContainsTrap { get; set; }
        public bool ContainsPuzzle { get; set; }
        public string QuestionInPuzzle { get; set; }
        public string AnswerOfPuzzle { get; set; }
        public List<Monster> Monsters { get; set; } = new();
        public List<Item> Items { get; set; } = new();
        public Dictionary<string, Room> Adjacent { get; set; } = new();

        public Room()
        {
            Description = string.Empty;
            ContainsTrap = false;
            ContainsPuzzle = false;
            QuestionInPuzzle = string.Empty;
            AnswerOfPuzzle = string.Empty;
            Monsters = new List<Monster>();
            Items = new List<Item>();
            Adjacent = new Dictionary<string, Room>();
        }

        public Room(string description) :this()
        {
            if (string.IsNullOrWhiteSpace(description))
                throw new ArgumentException("Room description required!", nameof(description));
            Description = description;
        }

        public void ContentsDescription()
        {
            Console.WriteLine($"\nThe description of the room is :{Description}\n");
            if (Monsters.Any())
            {
                Console.WriteLine("The monsters present in this room are: ");
                foreach (var m in Monsters)
                {
                    Console.WriteLine($"{m.Name} has {m.Health} health points.");

                }
            }

            else
            {
                Console.WriteLine("NO monsters are present here! ");

            }

            if (Items.Any())
            {
                Console.WriteLine("The items here are :");
                foreach (var i in Items)
                {
                    Console.WriteLine($"{i.Name} has a type of {i.GetType().Name}");
                }
            }

            else
            {
                Console.WriteLine("NO items are present here! ");
            }
            Console.WriteLine();
        }
    }

    public class GameMap
    {
        public ReadOnlyCollection<Room> Rooms { get; set; }
        public Room Present { get;  set; }

        public GameMap()
        {
            Rooms = new ReadOnlyCollection<Room>(new List<Room>());
            Present = null;
        }

        public GameMap(List<Room> rooms)
        {
            if (rooms == null || rooms.Count == 0)
                throw new ArgumentException("Rooms are required!", nameof(rooms));
            Rooms = new ReadOnlyCollection<Room>(rooms);
            Present = rooms[0];
        }

        public void Move(string direction)
        {
            if (!Present.Adjacent.TryGetValue(direction, out var next))
                throw new InvalidOperationException("Can't move in that direction!");
            Present = next;
        }
    }

    public static class GameMapMechanism
    {
        private static readonly List<string> _descriptions = new()
        {
            "A wet cave with glowing crystals",
            "A messy school library with scattered books",
            "A massive hall with torn walls",
            "A  dark, narrow corridor with bats everywhere ",
            "A haunted house with terrifying sounds being heard",
            "A small room with droplets of blood on the floor",
            "An isolated bungalow with the sound of the wind weezing from the window",
        };

        public static GameMap CreateDefault(int totalRooms = 7)
        {
            var rng = ProvideRandom.Instance;
            var rooms = new List<Room>();

            for (int i = 0; i < totalRooms; i++)
            {
                string description = _descriptions[rng.Next(_descriptions.Count)];
                rooms.Add(new Room(description));
            }

            for (int i = 0; i < rooms.Count; i++)
            {
                if (i < rooms.Count - 1) rooms[i].Adjacent["Right"] = rooms[i + 1];
                if (i > 0) rooms[i].Adjacent["Left"] = rooms[i - 1];
            }

            var weaponList = new List<Weapon>
            {
                new Weapon("Sword", rng.Next(6,20)),
                new Weapon("Axe", rng.Next(16,30)),
                new Weapon("Dagger", rng.Next(6,10)),
                new Weapon("Knife", rng.Next(3,12))
            };

            var potionList = new List<Potion>
            {
                new Potion("Health", rng.Next(15,40)),
                new Potion("Max", rng.Next(19,30)),
                new Potion("Stamina ", rng.Next(16,50))
            };

            foreach (var room in rooms)
            {
                for (int n = 0; n < rng.Next(4); n++)
                {
                    room.Monsters.Add(rng.Next(4) switch
                    {
                        0 => new Snake(),
                        1 => new Bat(),
                        2 => new Goblin(),
                        _ => new Troll(),
                    });
                }

                for (int n = 0; n < rng.Next(4); n++)
                {
                    room.Items.Add(rng.Next(4) switch
                    {
                        0 => weaponList[rng.Next(weaponList.Count)],
                        1 => potionList[rng.Next(potionList.Count)],
                        2 => new Key("Golden Key"),
                        _ => new Scroll("Magic Scroll", "Seek help to proceed!"),
                    });
                }
            }

            if (rooms.Count > 0) rooms[0].ContainsTrap = true;
            if (rooms.Count > 1)
            {
                var room = rooms[1];
                room.ContainsPuzzle = true;
                room.QuestionInPuzzle = "What has hands but can't clap?";
                room.AnswerOfPuzzle = "clock";
            }

            return new GameMap(rooms);
        }
    }

    public static class ManageSaveLoad
    {
        private static readonly JsonSerializerOptions Options = new()
        {
            WriteIndented = true,
            ReferenceHandler = ReferenceHandler.Preserve
        };

        

        private class State
        {
            public GameMap Map { get; set; }
            public Player Player { get; set; }
        }

        public static void Save(string path, GameMap map, Player player)
        {
            if (string.IsNullOrWhiteSpace(path))
                throw new ArgumentException("Path is required!");
            var state = new State { Map = map, Player = player };
            File.WriteAllText(path, JsonSerializer.Serialize(state, Options));
            
        }

        public static (GameMap, Player) Load(string path)
        {
            if (string.IsNullOrWhiteSpace(path) || !File.Exists(path))
                throw new FileNotFoundException("Saved fille is missing and unfound!");

            try  
            {
                using var file = File.OpenRead(path);
                var state = JsonSerializer.Deserialize<State>(file,Options)
                            ?? throw new InvalidOperationException("It was found that the deserialized state is null!");
                return (state.Map , state.Player);            
            } 

            catch (JsonException ex)
            {
                throw new InvalidOperationException("Saved file is invalid!" ,ex);
            } 

            catch (IOException ex)
            {
                throw new InvalidOperationException("Saved file CANNOT be read!");
            }


            
        }


        public static bool LoadTrial (string path, out GameMap? map , out Player? player)
        {
         map =  null;
         player = null;

         if (string.IsNullOrWhiteSpace(path) || !File.Exists(path))
            {
             return false;
            }

         try
            {
             using var file = File.OpenRead(path);
             var state = JsonSerializer.Deserialize<State>(file,Options);
             if (state == null)
                {
                 return false;
                }

             map   = state.Map;
             player = state.Player;
             return true;



            }

         catch (IOException)
            {
              return false;
            
            }

         catch (JsonException)
            {
             return false;
            }

        }    

    
    }

    public static class Testing
    {
        public static void FullRun()
        {
            Console.WriteLine("Tests are running .");

            //Test for damage
            var monsterTest = new Goblin();
            monsterTest.Damage(30);
            Console.WriteLine(monsterTest.Health == 30 ? "Goblin damage test is successful!" : "Goblin damage test is unsuccessful!");


            // Test for weapon attack
            var playerTest = new Player("Gamer", 100);
            playerTest.Attack(monsterTest);
            Console.WriteLine(monsterTest.Health < 50 ? "Player attack test is successful!" : "player attack test is unsuccessful!");

            // Test for collecting items
            var sword = new Weapon("Sword Test", 10);
            sword.Collect(playerTest);
            Console.WriteLine(playerTest.Inventory.Contains(sword) ? "Weapon collection test is succcessful!" : "Weapn collection test is unsuccessful!");

            //Test for healing
            playerTest.Damage(50);
            playerTest.Heal(30);
            Console.WriteLine(playerTest.Health == 80 ? "Player healing test is successful!" : "Player healing teast is unsuccessful!");

            // Leveling up test
            playerTest.GainScore(120);
            Console.WriteLine(playerTest.Level > 1 ? " Leveling up test is successful!" : "Leveling up test is unsuccessful!");
        }
    }

    public static class Program
    {
        private static string GetPosition(GameMap map, Player player)
        {
            int roomNumber = map.Rooms.IndexOf(map.Present) + 1;
            return $"Room number: {roomNumber} , Description: {map.Present.Description} , " +
                   $"Health : {player.Health} / {player.MaximumHealth} , " +
                   $" Total score : {player.totalScore} , Level : {player.Level} . ";
        }

        public static void Main()
        {
            //Automated tests before game start!
            Console.WriteLine("Automated tests are running .");
            Testing.FullRun();

            var map = GameMapMechanism.CreateDefault();
            var player = new Player();

            Console.WriteLine("Welcome to a new adventure in  Dungeon Explorer!");

            while (player._Alive)
            {
                Console.WriteLine(GetPosition(map, player));
                if (map.Present.ContainsPuzzle)
                {
                    Console.WriteLine($"Puzzle: {map.Present.QuestionInPuzzle}");
                    Console.Write("Answer: ");
                    var answer = Console.ReadLine()?.Trim().ToLower();
                    if (answer == map.Present.AnswerOfPuzzle.ToLower())
                    {
                        Console.WriteLine("Correct! You solved the puzzle!");
                        player.GainScore(50);
                        map.Present.ContainsPuzzle = false;
                    }
                    else
                    {
                        Console.WriteLine("Incorrect answer! Try again later!");
                        continue;
                    }
                }
                if (map.Present.ContainsTrap)
                {
                    const int trapDamage = 10;
                    Console.WriteLine("You fell into the trap! " + trapDamage +  " " + "damage!");
                    player.Damage(trapDamage);
                    map.Present.ContainsTrap = false; // only one trigger.
                    if (!player._Alive)
                    {
                        Console.WriteLine("\nA trap killed you ! Game over !");
                        return;
                    }
                }

                map.Present.ContentsDescription();

                Console.WriteLine("\nStrongest monster in the room:");
                map.Present.Monsters
                    .OrderByDescending(m => m.Health)
                    .ToList()
                    .ForEach(m => Console.WriteLine($"{m.Name}: {m.Health} HealthPoints"));


                Console.WriteLine("\nItems in room (grouped by type):");
                map.Present.Items
                    .GroupBy(i => i.GetType().Name)
                    .ToList()
                    .ForEach(g => Console.WriteLine($"{g.Key}: {g.Count()}"));


                Console.Write("\nWhat do you want to do? (move between rooms [Left/Right], attack(for Snake and Goblin monsters), strike (for Bat and Troll monsters), pickup (itemname), use (potionname), save, load, exit, destroy (weapon name): ");
                var input = Console.ReadLine()?.Split(' ', StringSplitOptions.RemoveEmptyEntries);

                if (input == null || input.Length == 0) continue;

                try
                {
                    switch (input[0].ToLower())
                    {
                        case "strike":
                            {
                                var mon = map.Present.Monsters.FirstOrDefault()
                                         ?? throw new InvalidOperationException("No monsters to strike!");
                                mon.DoStrike(player);
                                if (!mon._Alive)
                                {
                                    player.GainScore(mon.Health > 50 ? 50 : 20);
                                    map.Present.Monsters.Remove(mon);
                                    Console.WriteLine("Monster defeated!");
                                }
                                break;
                            }
                        case "move":
                            if (input.Length < 2)
                                throw new ArgumentException("Direction required!");
                            map.Move(input[1]);
                            break;

                        case "attack":
                            {
                                var mon = map.Present.Monsters.FirstOrDefault()
                                    ?? throw new InvalidOperationException("No monsters to attack!");
                                player.Attack(mon);
                                if (!mon._Alive)
                                {
                                    player.GainScore(mon.Health > 50 ? 50 : 20);
                                    map.Present.Monsters.Remove(mon);
                                    Console.WriteLine("Monster defeated!");
                                }
                                break;
                            }

                        case "pickup":
                            if (input.Length < 2)
                                throw new ArgumentException("Item name required!");
                            var itemName = string.Join(" ", input.Skip(1));
                            var itm = map.Present.Items
                                .FirstOrDefault(i => i.Name
                                          .Equals(itemName, StringComparison.OrdinalIgnoreCase))
                                ?? throw new InvalidOperationException($"Item {itemName} is NOT found!");
                            itm.Collect(player);
                            map.Present.Items.Remove(itm);
                            break;

                        case "use":
                            if (input.Length < 2)
                                throw new ArgumentException("Potion name required!");
                            var potionName = string.Join(" ", input.Skip(1));
                            var potion = player.Inventory.OfType<Potion>()
                                .FirstOrDefault(p => p.Name.Equals(potionName, StringComparison.OrdinalIgnoreCase))
                                ?? throw new InvalidOperationException($"Potion: {potionName} is NOT found!");
                            player.Heal(potion.AmountOfHealing);
                            player.InventoryRemove(potion);
                            break;

                        case "destroy":
                            {
                                if (input.Length < 2)
                                    throw new ArgumentException("Weapon name required!");

                        
                                var weaponName = string.Join(" ", input.Skip(1));
                                var weapon = player.Inventory
                                                   .OfType<Weapon>()
                                                   .FirstOrDefault(w =>
                                                       w.Name.Equals(weaponName, StringComparison.OrdinalIgnoreCase))
                                             ?? throw new InvalidOperationException($"Weapon '{weaponName}' is NOT found!");

                                
                                var monster = map.Present.Monsters
                                                 .FirstOrDefault()
                                             ?? throw new InvalidOperationException("No monsters to destroy!");

                               
                                Console.WriteLine($"{player.Name} uses {weapon.Name} to hit {monster.Name} for {weapon.Damage} damage!");
                                monster.Damage(weapon.Damage);

                                
                                if (!monster._Alive)
                                {
                                    map.Present.Monsters.Remove(monster);
                                    int earned = monster.Health > 50 ? 50 : 20;
                                    player.GainScore(earned);
                                    Console.WriteLine($"{monster.Name} is destroyed! You earned {earned} points.");
                                }

                                break;
                            }



                        case "save":
                            ManageSaveLoad.Save("Save.json", map, player);
                            Console.WriteLine("Game saved successfully!");
                            break;

                        case "load":
                            (map, player) = ManageSaveLoad.Load("Save.json");
                            Console.WriteLine("Game loaded successfully!");
                            break;

                        case "exit":
                            Console.WriteLine("Exit in progress. Goodbye!");
                            return;

                        default:
                            Console.WriteLine("Invalid input!  Try again.");
                            break;
                    }

                    if (player.totalScore >= 600)
                    {
                        Console.WriteLine("\nCongratulations! You WON game!");
                        break;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[Error] {ex.Message}");
                }
            }

            if (!player._Alive)
            {
                Console.WriteLine("\nHard luck! You LOST! Game Over!");
            }
        }
    }
}